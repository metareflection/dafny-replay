// Generated by dafny2js
// Do not edit manually - regenerate from Dafny sources

import BigNumber from 'bignumber.js';

// Configure BigNumber as Dafny expects
BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });

// Import the generated code as raw text
import dafnyCode from './ClearSplit.cjs?raw';

// Set up the environment and evaluate the Dafny code
const require = (mod: string) => {
  if (mod === 'bignumber.js') return BigNumber;
  throw new Error(`Unknown module: ${mod}`);
};

// Create a function that evaluates the code with proper scope
const initDafny = new Function('require', `
  ${dafnyCode}
  return { _dafny, ClearSplit, ClearSplitAppCore };
`);

const { _dafny, ClearSplit, ClearSplitAppCore } = initDafny(require);

// ============================================================================
// Helpers
// ============================================================================

// deno-lint-ignore no-explicit-any
const seqToArray = (seq: any): any[] => {
  const arr = [];
  for (let i = 0; i < seq.length; i++) {
    arr.push(seq[i]);
  }
  return arr;
};

// deno-lint-ignore no-explicit-any
const toNumber = (bn: any): number => {
  if (bn && typeof bn.toNumber === 'function') {
    return bn.toNumber();
  }
  return bn;
};

// deno-lint-ignore no-explicit-any
const dafnyStringToJs = (seq: any): string => {
  if (typeof seq === 'string') return seq;
  if (seq.toVerbatimString) return seq.toVerbatimString(false);
  return Array.from(seq).join('');
};


// ============================================================================
// TypeScript Type Definitions (JSON representation)
// ============================================================================

export interface Expense {
  paidBy: string;
  amount: number;
  shares: Record<string, number>;
  shareKeys: string[];
}

export interface Settlement {
  from: string;
  to: string;
  amount: number;
}

export interface Model {
  members: string[];
  memberList: string[];
  expenses: Expense[];
  settlements: Settlement[];
}

export type Result<T, E> =
  | { type: 'Ok'; value: unknown }
  | { type: 'Error'; error: unknown };

export type Err =
  | { type: 'NotMember'; p: string }
  | { type: 'BadExpense' }
  | { type: 'BadSettlement' };

export type Action =
  | { type: 'AddExpense'; e: Expense }
  | { type: 'AddSettlement'; s: Settlement };

export interface Certificate {
  memberCount: number;
  expenseCount: number;
  settlementCount: number;
  conservationHolds: boolean;
}

// ============================================================================
// Dafny Runtime Types (actual Dafny runtime object shapes)
// ============================================================================

// Base Dafny runtime types
type DafnyInt = InstanceType<typeof BigNumber>;
interface DafnySeq<T = unknown> {
  readonly length: number;
  readonly [index: number]: T;
  toVerbatimString?(asLiteral: boolean): string;
  map<U>(fn: (x: T) => U): U[];
}
interface DafnySet<T = unknown> { readonly Elements: Iterable<T>; }
interface DafnyMap<K = unknown, V = unknown> {
  readonly Keys: DafnySet<K>;
  get(key: K): V;
  contains(key: K): boolean;
}

interface DafnyExpense {
  readonly is_Expense: true;
  readonly dtor_paidBy: DafnySeq;
  readonly dtor_amount: DafnyInt;
  readonly dtor_shares: DafnyMap<DafnySeq, DafnyInt>;
  readonly dtor_shareKeys: DafnySeq<DafnySeq>;
}

interface DafnySettlement {
  readonly is_Settlement: true;
  readonly dtor_from: DafnySeq;
  readonly dtor_to: DafnySeq;
  readonly dtor_amount: DafnyInt;
}

interface DafnyModel {
  readonly is_Model: true;
  readonly dtor_members: DafnySet<DafnySeq>;
  readonly dtor_memberList: DafnySeq<DafnySeq>;
  readonly dtor_expenses: DafnySeq<DafnyExpense>;
  readonly dtor_settlements: DafnySeq<DafnySettlement>;
}

type DafnyResult<T, E> = { readonly is_Ok: true; readonly is_Error: false; readonly dtor_value: T } | { readonly is_Ok: false; readonly is_Error: true; readonly dtor_error: E };

type DafnyErr = { readonly is_NotMember: true; readonly is_BadExpense: false; readonly is_BadSettlement: false; readonly dtor_p: DafnySeq } | { readonly is_NotMember: false; readonly is_BadExpense: true; readonly is_BadSettlement: false } | { readonly is_NotMember: false; readonly is_BadExpense: false; readonly is_BadSettlement: true };

type DafnyAction = { readonly is_AddExpense: true; readonly is_AddSettlement: false; readonly dtor_e: DafnyExpense } | { readonly is_AddExpense: false; readonly is_AddSettlement: true; readonly dtor_s: DafnySettlement };

interface DafnyCertificate {
  readonly is_Certificate: true;
  readonly dtor_memberCount: DafnyInt;
  readonly dtor_expenseCount: DafnyInt;
  readonly dtor_settlementCount: DafnyInt;
  readonly dtor_conservationHolds: boolean;
}

// ============================================================================
// Datatype Conversions
// ============================================================================

// deno-lint-ignore no-explicit-any
const expenseFromJson = (json: any): DafnyExpense => {
  let __shares = _dafny.Map.Empty;
  for (const [k, v] of (Object.entries(json.shares || {}) as [string, any][])) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = new BigNumber(v);
    __shares = __shares.update(key, val);
  }
  return ClearSplit.Expense.create_Expense(
    _dafny.Seq.UnicodeFromString(json.paidBy),
    new BigNumber(json.amount),
    __shares,
    _dafny.Seq.of(...(json.shareKeys || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))
  );
};

// deno-lint-ignore no-explicit-any
const expenseToJson = (value: any): Expense => {
  const __sharesJson: Record<string, any> = {};
  if (value.dtor_shares && value.dtor_shares.Keys) {
    for (const k of value.dtor_shares.Keys.Elements) {
      const v = value.dtor_shares.get(k);
      __sharesJson[dafnyStringToJs(k)] = toNumber(v);
    }
  }
  return {
    paidBy: dafnyStringToJs(value.dtor_paidBy),
    amount: toNumber(value.dtor_amount),
    shares: __sharesJson,
    shareKeys: seqToArray(value.dtor_shareKeys).map((x: any) => dafnyStringToJs(x))
  };
};

// deno-lint-ignore no-explicit-any
const settlementFromJson = (json: any): DafnySettlement => {
  return ClearSplit.Settlement.create_Settlement(
    _dafny.Seq.UnicodeFromString(json.from),
    _dafny.Seq.UnicodeFromString(json.to),
    new BigNumber(json.amount)
  );
};

// deno-lint-ignore no-explicit-any
const settlementToJson = (value: any): Settlement => {
  return {
    from: dafnyStringToJs(value.dtor_from),
    to: dafnyStringToJs(value.dtor_to),
    amount: toNumber(value.dtor_amount)
  };
};

// deno-lint-ignore no-explicit-any
const modelFromJson = (json: any): DafnyModel => {
  return ClearSplit.Model.create_Model(
    _dafny.Set.fromElements(...(json.members || []).map((x: any) => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Seq.of(...(json.memberList || []).map((x: any) => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Seq.of(...(json.expenses || []).map((x: any) => expenseFromJson(x))),
    _dafny.Seq.of(...(json.settlements || []).map((x: any) => settlementFromJson(x)))
  );
};

// deno-lint-ignore no-explicit-any
const modelToJson = (value: any): Model => {
  return {
    members: Array.from(value.dtor_members.Elements).map((x: any) => dafnyStringToJs(x)),
    memberList: seqToArray(value.dtor_memberList).map((x: any) => dafnyStringToJs(x)),
    expenses: seqToArray(value.dtor_expenses).map((x: any) => expenseToJson(x)),
    settlements: seqToArray(value.dtor_settlements).map((x: any) => settlementToJson(x))
  };
};

// deno-lint-ignore no-explicit-any
const resultFromJson = <T, E>(json: any, T_fromJson: (x: any) => T, E_fromJson: (x: any) => E): DafnyResult<T, E> => {
  switch (json.type) {
    case 'Ok': {
      return ClearSplit.Result.create_Ok(
        T_fromJson(json.value)
      );
    }
    case 'Error': {
      return ClearSplit.Result.create_Error(
        E_fromJson(json.error)
      );
    }
    default:
      throw new Error(`Unknown Result type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const resultToJson = <T, E>(value: any, T_toJson: (x: any) => any, E_toJson: (x: any) => any): Result<T, E> => {
  if (value.is_Ok) {
    return {
      type: 'Ok',
      value: T_toJson(value.dtor_value)
    };
  } else if (value.is_Error) {
    return {
      type: 'Error',
      error: E_toJson(value.dtor_error)
    };
  }
  throw new Error('Unknown Result variant');
};

// deno-lint-ignore no-explicit-any
const errFromJson = (json: any): DafnyErr => {
  switch (json.type) {
    case 'NotMember': {
      return ClearSplit.Err.create_NotMember(
        _dafny.Seq.UnicodeFromString(json.p)
      );
    }
    case 'BadExpense': {
      return ClearSplit.Err.create_BadExpense();
    }
    case 'BadSettlement': {
      return ClearSplit.Err.create_BadSettlement();
    }
    default:
      throw new Error(`Unknown Err type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const errToJson = (value: any): Err => {
  if (value.is_NotMember) {
    return {
      type: 'NotMember',
      p: dafnyStringToJs(value.dtor_p)
    };
  } else if (value.is_BadExpense) {
    return { type: 'BadExpense' };
  } else if (value.is_BadSettlement) {
    return { type: 'BadSettlement' };
  }
  throw new Error('Unknown Err variant');
};

// deno-lint-ignore no-explicit-any
const actionFromJson = (json: any): DafnyAction => {
  switch (json.type) {
    case 'AddExpense': {
      return ClearSplit.Action.create_AddExpense(
        expenseFromJson(json.e)
      );
    }
    case 'AddSettlement': {
      return ClearSplit.Action.create_AddSettlement(
        settlementFromJson(json.s)
      );
    }
    default:
      throw new Error(`Unknown Action type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const actionToJson = (value: any): Action => {
  if (value.is_AddExpense) {
    return {
      type: 'AddExpense',
      e: expenseToJson(value.dtor_e)
    };
  } else if (value.is_AddSettlement) {
    return {
      type: 'AddSettlement',
      s: settlementToJson(value.dtor_s)
    };
  }
  throw new Error('Unknown Action variant');
};

// deno-lint-ignore no-explicit-any
const certificateFromJson = (json: any): DafnyCertificate => {
  return ClearSplit.Certificate.create_Certificate(
    new BigNumber(json.memberCount),
    new BigNumber(json.expenseCount),
    new BigNumber(json.settlementCount),
    json.conservationHolds
  );
};

// deno-lint-ignore no-explicit-any
const certificateToJson = (value: any): Certificate => {
  return {
    memberCount: toNumber(value.dtor_memberCount),
    expenseCount: toNumber(value.dtor_expenseCount),
    settlementCount: toNumber(value.dtor_settlementCount),
    conservationHolds: value.dtor_conservationHolds
  };
};

// ============================================================================
// API Wrapper
// ============================================================================

interface AppInternal { _dafny: unknown; ClearSplit: unknown; ClearSplitAppCore: unknown; }

const App = {
  // Expense constructors
  Expense: (paidBy: string, amount: number, shares: Record<string, number>, shareKeys: string[]) => ClearSplit.Expense.create_Expense(_dafny.Seq.UnicodeFromString(paidBy), new BigNumber(amount), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(shares), _dafny.Seq.of(...(shareKeys || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))),

  // Settlement constructors
  Settlement: (from: string, to: string, amount: number) => ClearSplit.Settlement.create_Settlement(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to), new BigNumber(amount)),

  // Result constructors
  Ok: (value: unknown) => ClearSplit.Result.create_Ok(value),
  Error: (error: unknown) => ClearSplit.Result.create_Error(error),

  // Err constructors
  NotMember: (p: string) => ClearSplit.Err.create_NotMember(_dafny.Seq.UnicodeFromString(p)),
  BadExpense: () => ClearSplit.Err.create_BadExpense(),
  BadSettlement: () => ClearSplit.Err.create_BadSettlement(),

  // Certificate constructors
  Certificate: (memberCount: number, expenseCount: number, settlementCount: number, conservationHolds: boolean) => ClearSplit.Certificate.create_Certificate(new BigNumber(memberCount), new BigNumber(expenseCount), new BigNumber(settlementCount), conservationHolds),

  // Action constructors
  AddExpense: (e: DafnyExpense) => ClearSplit.Action.create_AddExpense(e),
  AddSettlement: (s: DafnySettlement) => ClearSplit.Action.create_AddSettlement(s),

  // Model accessors
  GetMembers: (m: DafnyModel) => Array.from(m.dtor_members.Elements).map((x: any) => dafnyStringToJs(x)),
  GetMemberList: (m: DafnyModel) => seqToArray(m.dtor_memberList).map((x: any) => dafnyStringToJs(x)),
  GetExpenses: (m: DafnyModel) => seqToArray(m.dtor_expenses).map((x: any) => expenseToJson(x)),
  GetSettlements: (m: DafnyModel) => seqToArray(m.dtor_settlements).map((x: any) => settlementToJson(x)),

  // AppCore functions
  MakeExpense: (paidBy: string, amount: number, shares: Record<string, number>, shareKeys: string[]): DafnyExpense => ClearSplitAppCore.__default.MakeExpense(_dafny.Seq.UnicodeFromString(paidBy), new BigNumber(amount), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(shares), _dafny.Seq.of(...(shareKeys || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))),
  MakeSettlement: (from: string, to: string, amount: number): DafnySettlement => ClearSplitAppCore.__default.MakeSettlement(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to), new BigNumber(amount)),
  Balances: (model: DafnyModel): DafnyMap<DafnySeq, DafnyInt> => ClearSplitAppCore.__default.Balances(model),
  GetBalance: (model: DafnyModel, p: string): number => toNumber(ClearSplitAppCore.__default.GetBalance(model, _dafny.Seq.UnicodeFromString(p))),
  Members: (model: DafnyModel): string[] => seqToArray(ClearSplitAppCore.__default.Members(model)).map(x => dafnyStringToJs(x)),
  Expenses: (model: DafnyModel): Expense[] => seqToArray(ClearSplitAppCore.__default.Expenses(model)).map(x => expenseToJson(x)),
  Settlements: (model: DafnyModel): Settlement[] => seqToArray(ClearSplitAppCore.__default.Settlements(model)).map(x => settlementToJson(x)),

  // Conversion functions
  expenseToJson,
  expenseFromJson,
  settlementToJson,
  settlementFromJson,
  modelToJson,
  modelFromJson,
  resultToJson,
  resultFromJson,
  errToJson,
  errFromJson,
  actionToJson,
  actionFromJson,
  certificateToJson,
  certificateFromJson,

  // Internal modules for custom extensions
  _internal: { _dafny, ClearSplit, ClearSplitAppCore } as AppInternal,
};

export default App;
