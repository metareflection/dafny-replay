// Generated by dafny2js
// Do not edit manually - regenerate from Dafny sources

import BigNumber from 'bignumber.js';

// Configure BigNumber as Dafny expects
BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });

// Import the generated code as raw text
import dafnyCode from './ClearSplit.cjs?raw';

// Set up the environment and evaluate the Dafny code
const require = (mod) => {
  if (mod === 'bignumber.js') return BigNumber;
  throw new Error(`Unknown module: ${mod}`);
};

// Create a function that evaluates the code with proper scope
const initDafny = new Function('require', `
  ${dafnyCode}
  return { _dafny, ClearSplit, ClearSplitAppCore };
`);

const { _dafny, ClearSplit, ClearSplitAppCore } = initDafny(require);


// ============================================================================
// Helpers
// ============================================================================

// Convert Dafny seq to JS array
const seqToArray = (seq) => {
  const arr = [];
  for (let i = 0; i < seq.length; i++) {
    arr.push(seq[i]);
  }
  return arr;
};

// Convert BigNumber to JS number
const toNumber = (bn) => {
  if (bn && typeof bn.toNumber === 'function') {
    return bn.toNumber();
  }
  return bn;
};

// Convert Dafny string to JS string
const dafnyStringToJs = (seq) => {
  if (typeof seq === 'string') return seq;
  if (seq.toVerbatimString) return seq.toVerbatimString(false);
  return Array.from(seq).join('');
};

// ============================================================================
// Datatype Conversions
// ============================================================================

const expenseFromJson = (json) => {
  let __shares = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.shares || {})) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = new BigNumber(v);
    __shares = __shares.update(key, val);
  }
  return ClearSplit.Expense.create_Expense(
    _dafny.Seq.UnicodeFromString(json.paidBy),
    new BigNumber(json.amount),
    __shares,
    _dafny.Seq.of(...(json.shareKeys || []).map(x => _dafny.Seq.UnicodeFromString(x)))
  );
};

const expenseToJson = (value) => {
  const __sharesJson = {};
  if (value.dtor_shares && value.dtor_shares.Keys) {
    for (const k of value.dtor_shares.Keys.Elements) {
      const v = value.dtor_shares.get(k);
      __sharesJson[dafnyStringToJs(k)] = toNumber(v);
    }
  }
  return {
    paidBy: dafnyStringToJs(value.dtor_paidBy),
    amount: toNumber(value.dtor_amount),
    shares: __sharesJson,
    shareKeys: seqToArray(value.dtor_shareKeys).map(x => dafnyStringToJs(x))
  };
};

const settlementFromJson = (json) => {
  return ClearSplit.Settlement.create_Settlement(
    _dafny.Seq.UnicodeFromString(json.from),
    _dafny.Seq.UnicodeFromString(json.to),
    new BigNumber(json.amount)
  );
};

const settlementToJson = (value) => {
  return {
    from: dafnyStringToJs(value.dtor_from),
    to: dafnyStringToJs(value.dtor_to),
    amount: toNumber(value.dtor_amount)
  };
};

const modelFromJson = (json) => {
  return ClearSplit.Model.create_Model(
    _dafny.Set.fromElements(...(json.members || []).map(x => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Seq.of(...(json.memberList || []).map(x => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Seq.of(...(json.expenses || []).map(x => expenseFromJson(x))),
    _dafny.Seq.of(...(json.settlements || []).map(x => settlementFromJson(x)))
  );
};

const modelToJson = (value) => {
  return {
    members: Array.from(value.dtor_members.Elements).map(x => dafnyStringToJs(x)),
    memberList: seqToArray(value.dtor_memberList).map(x => dafnyStringToJs(x)),
    expenses: seqToArray(value.dtor_expenses).map(x => expenseToJson(x)),
    settlements: seqToArray(value.dtor_settlements).map(x => settlementToJson(x))
  };
};

const resultFromJson = (json, T_fromJson, E_fromJson) => {
  switch (json.type) {
    case 'Ok': {
      return ClearSplit.Result.create_Ok(
        T_fromJson(json.value)
      );
    }
    case 'Error': {
      return ClearSplit.Result.create_Error(
        E_fromJson(json.error)
      );
    }
    default:
      throw new Error(`Unknown Result type: ${json.type}`);
  }
};

const resultToJson = (value, T_toJson, E_toJson) => {
  if (value.is_Ok) {
    return {
      type: 'Ok',
      value: T_toJson(value.dtor_value)
    };
  } else if (value.is_Error) {
    return {
      type: 'Error',
      error: E_toJson(value.dtor_error)
    };
  }
  return { type: 'Unknown' };
};

const errFromJson = (json) => {
  switch (json.type) {
    case 'NotMember': {
      return ClearSplit.Err.create_NotMember(
        _dafny.Seq.UnicodeFromString(json.p)
      );
    }
    case 'BadExpense': {
      return ClearSplit.Err.create_BadExpense();
    }
    case 'BadSettlement': {
      return ClearSplit.Err.create_BadSettlement();
    }
    default:
      throw new Error(`Unknown Err type: ${json.type}`);
  }
};

const errToJson = (value) => {
  if (value.is_NotMember) {
    return {
      type: 'NotMember',
      p: dafnyStringToJs(value.dtor_p)
    };
  } else if (value.is_BadExpense) {
    return { type: 'BadExpense' };
  } else if (value.is_BadSettlement) {
    return { type: 'BadSettlement' };
  }
  return { type: 'Unknown' };
};

const actionFromJson = (json) => {
  switch (json.type) {
    case 'AddExpense': {
      return ClearSplit.Action.create_AddExpense(
        expenseFromJson(json.e)
      );
    }
    case 'AddSettlement': {
      return ClearSplit.Action.create_AddSettlement(
        settlementFromJson(json.s)
      );
    }
    default:
      throw new Error(`Unknown Action type: ${json.type}`);
  }
};

const actionToJson = (value) => {
  if (value.is_AddExpense) {
    return {
      type: 'AddExpense',
      e: expenseToJson(value.dtor_e)
    };
  } else if (value.is_AddSettlement) {
    return {
      type: 'AddSettlement',
      s: settlementToJson(value.dtor_s)
    };
  }
  return { type: 'Unknown' };
};

const certificateFromJson = (json) => {
  return ClearSplit.Certificate.create_Certificate(
    new BigNumber(json.memberCount),
    new BigNumber(json.expenseCount),
    new BigNumber(json.settlementCount),
    json.conservationHolds
  );
};

const certificateToJson = (value) => {
  return {
    memberCount: toNumber(value.dtor_memberCount),
    expenseCount: toNumber(value.dtor_expenseCount),
    settlementCount: toNumber(value.dtor_settlementCount),
    conservationHolds: value.dtor_conservationHolds
  };
};

// ============================================================================
// API Wrapper
// ============================================================================

const App = {
  // Expense constructors
  Expense: (paidBy, amount, shares, shareKeys) => ClearSplit.Expense.create_Expense(_dafny.Seq.UnicodeFromString(paidBy), new BigNumber(amount), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(shares), _dafny.Seq.of(...(shareKeys || []).map(x => _dafny.Seq.UnicodeFromString(x)))),

  // Settlement constructors
  Settlement: (from, to, amount) => ClearSplit.Settlement.create_Settlement(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to), new BigNumber(amount)),

  // Result constructors
  Ok: (value) => ClearSplit.Result.create_Ok(value),
  Error: (error) => ClearSplit.Result.create_Error(error),

  // Err constructors
  NotMember: (p) => ClearSplit.Err.create_NotMember(_dafny.Seq.UnicodeFromString(p)),
  BadExpense: () => ClearSplit.Err.create_BadExpense(),
  BadSettlement: () => ClearSplit.Err.create_BadSettlement(),

  // Certificate constructors
  Certificate: (memberCount, expenseCount, settlementCount, conservationHolds) => ClearSplit.Certificate.create_Certificate(new BigNumber(memberCount), new BigNumber(expenseCount), new BigNumber(settlementCount), conservationHolds),

  // Action constructors
  AddExpense: (e) => ClearSplit.Action.create_AddExpense(e),
  AddSettlement: (s) => ClearSplit.Action.create_AddSettlement(s),

  // Model accessors
  GetMembers: (m) => Array.from(m.dtor_members.Elements).map(x => dafnyStringToJs(x)),
  GetMemberList: (m) => seqToArray(m.dtor_memberList).map(x => dafnyStringToJs(x)),
  GetExpenses: (m) => seqToArray(m.dtor_expenses).map(x => expenseToJson(x)),
  GetSettlements: (m) => seqToArray(m.dtor_settlements).map(x => settlementToJson(x)),

  // AppCore functions
  MakeExpense: (paidBy, amount, shares, shareKeys) => ClearSplitAppCore.__default.MakeExpense(_dafny.Seq.UnicodeFromString(paidBy), new BigNumber(amount), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(shares), _dafny.Seq.of(...(shareKeys || []).map(x => _dafny.Seq.UnicodeFromString(x)))),
  MakeSettlement: (from, to, amount) => ClearSplitAppCore.__default.MakeSettlement(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to), new BigNumber(amount)),
  Balances: (model) => ClearSplitAppCore.__default.Balances(model),
  GetBalance: (model, p) => toNumber(ClearSplitAppCore.__default.GetBalance(model, _dafny.Seq.UnicodeFromString(p))),
  Members: (model) => seqToArray(ClearSplitAppCore.__default.Members(model)).map(x => dafnyStringToJs(x)),
  Expenses: (model) => seqToArray(ClearSplitAppCore.__default.Expenses(model)).map(x => expenseToJson(x)),
  Settlements: (model) => seqToArray(ClearSplitAppCore.__default.Settlements(model)).map(x => settlementToJson(x)),

  // Conversion functions
  expenseToJson: expenseToJson,
  expenseFromJson: expenseFromJson,
  settlementToJson: settlementToJson,
  settlementFromJson: settlementFromJson,
  modelToJson: modelToJson,
  modelFromJson: modelFromJson,
  resultToJson: resultToJson,
  resultFromJson: resultFromJson,
  errToJson: errToJson,
  errFromJson: errFromJson,
  actionToJson: actionToJson,
  actionFromJson: actionFromJson,
  certificateToJson: certificateToJson,
  certificateFromJson: certificateFromJson,
};

// Export internals for custom extensions
App._internal = { _dafny, ClearSplit, ClearSplitAppCore };

export default App;
