// Generated by dafny2js
// Do not edit manually - regenerate from Dafny sources

import BigNumber from 'bignumber.js';

// Configure BigNumber as Dafny expects
BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });

// Import the generated code as raw text
import dafnyCode from './TodoMultiProjectEffect.cjs?raw';

// Set up the environment and evaluate the Dafny code
const require = (mod) => {
  if (mod === 'bignumber.js') return BigNumber;
  throw new Error(`Unknown module: ${mod}`);
};

// Create a function that evaluates the code with proper scope
const initDafny = new Function('require', `
  ${dafnyCode}
  return { _dafny, TodoDomain, TodoMultiProjectDomain, TodoMultiProjectEffectStateMachine, TodoMultiProjectEffectAppCore };
`);

const { _dafny, TodoDomain, TodoMultiProjectDomain, TodoMultiProjectEffectStateMachine, TodoMultiProjectEffectAppCore } = initDafny(require);


// ============================================================================
// Helpers
// ============================================================================

// Convert Dafny seq to JS array
const seqToArray = (seq) => {
  const arr = [];
  for (let i = 0; i < seq.length; i++) {
    arr.push(seq[i]);
  }
  return arr;
};

// Convert BigNumber to JS number
const toNumber = (bn) => {
  if (bn && typeof bn.toNumber === 'function') {
    return bn.toNumber();
  }
  return bn;
};

// Convert Dafny string to JS string
const dafnyStringToJs = (seq) => {
  if (typeof seq === 'string') return seq;
  if (seq.toVerbatimString) return seq.toVerbatimString(false);
  return Array.from(seq).join('');
};

// ============================================================================
// Datatype Conversions
// ============================================================================

const optionFromJson = (json, T_fromJson) => {
  switch (json.type) {
    case 'None': {
      return TodoDomain.Option.create_None();
    }
    case 'Some': {
      return TodoDomain.Option.create_Some(
        T_fromJson(json.value)
      );
    }
    default:
      throw new Error(`Unknown Option type: ${json.type}`);
  }
};

const optionToJson = (value, T_toJson) => {
  if (value.is_None) {
    return { type: 'None' };
  } else if (value.is_Some) {
    return {
      type: 'Some',
      value: T_toJson(value.dtor_value)
    };
  }
  return { type: 'Unknown' };
};

const dateFromJson = (json) => {
  return TodoDomain.Date.create_Date(
    new BigNumber(json.year),
    new BigNumber(json.month),
    new BigNumber(json.day)
  );
};

const dateToJson = (value) => {
  return {
    year: toNumber(value.dtor_year),
    month: toNumber(value.dtor_month),
    day: toNumber(value.dtor_day)
  };
};

const taskFromJson = (json) => {
  return TodoDomain.Task.create_Task(
    _dafny.Seq.UnicodeFromString(json.title),
    _dafny.Seq.UnicodeFromString(json.notes),
    json.completed,
    json.starred,
    optionFromJson(json.dueDate, dateFromJson),
    _dafny.Set.fromElements(...(json.assignees || []).map(x => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Set.fromElements(...(json.tags || []).map(x => new BigNumber(x))),
    json.deleted,
    optionFromJson(json.deletedBy, (x) => _dafny.Seq.UnicodeFromString(x)),
    optionFromJson(json.deletedFromList, (x) => new BigNumber(x))
  );
};

const taskToJson = (value) => {
  return {
    title: dafnyStringToJs(value.dtor_title),
    notes: dafnyStringToJs(value.dtor_notes),
    completed: value.dtor_completed,
    starred: value.dtor_starred,
    dueDate: optionToJson(value.dtor_dueDate, dateToJson),
    assignees: Array.from(value.dtor_assignees.Elements).map(x => dafnyStringToJs(x)),
    tags: Array.from(value.dtor_tags.Elements).map(x => toNumber(x)),
    deleted: value.dtor_deleted,
    deletedBy: optionToJson(value.dtor_deletedBy, dafnyStringToJs),
    deletedFromList: optionToJson(value.dtor_deletedFromList, toNumber)
  };
};

const tagFromJson = (json) => {
  return TodoDomain.Tag.create_Tag(
    _dafny.Seq.UnicodeFromString(json.name)
  );
};

const tagToJson = (value) => {
  return {
    name: dafnyStringToJs(value.dtor_name)
  };
};

const projectmodeFromJson = (json) => {
  switch (json) {
    case 'Personal':
      return TodoDomain.ProjectMode.create_Personal();
    case 'Collaborative':
      return TodoDomain.ProjectMode.create_Collaborative();
    default:
      throw new Error(`Unknown ProjectMode: ${json}`);
  }
};

const projectmodeToJson = (value) => {
  if (value.is_Personal) {
    return 'Personal';
  } else if (value.is_Collaborative) {
    return 'Collaborative';
  }
  return 'Unknown';
};

const modelFromJson = (json) => {
  let __listNames = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.listNames || {})) {
    const key = new BigNumber(k);
    const val = _dafny.Seq.UnicodeFromString(v);
    __listNames = __listNames.update(key, val);
  }
  let __tasks = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.tasks || {})) {
    const key = new BigNumber(k);
    const val = _dafny.Seq.of(...(v || []).map(x => new BigNumber(x)));
    __tasks = __tasks.update(key, val);
  }
  let __taskData = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.taskData || {})) {
    const key = new BigNumber(k);
    const val = taskFromJson(v);
    __taskData = __taskData.update(key, val);
  }
  let __tags = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.tags || {})) {
    const key = new BigNumber(k);
    const val = tagFromJson(v);
    __tags = __tags.update(key, val);
  }
  return TodoDomain.Model.create_Model(
    projectmodeFromJson(json.mode),
    _dafny.Seq.UnicodeFromString(json.owner),
    _dafny.Set.fromElements(...(json.members || []).map(x => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Seq.of(...(json.lists || []).map(x => new BigNumber(x))),
    __listNames,
    __tasks,
    __taskData,
    __tags,
    new BigNumber(json.nextListId),
    new BigNumber(json.nextTaskId),
    new BigNumber(json.nextTagId)
  );
};

const modelToJson = (value) => {
  const __listNamesJson = {};
  if (value.dtor_listNames && value.dtor_listNames.Keys) {
    for (const k of value.dtor_listNames.Keys.Elements) {
      const v = value.dtor_listNames.get(k);
      __listNamesJson[toNumber(k)] = dafnyStringToJs(v);
    }
  }
  const __tasksJson = {};
  if (value.dtor_tasks && value.dtor_tasks.Keys) {
    for (const k of value.dtor_tasks.Keys.Elements) {
      const v = value.dtor_tasks.get(k);
      __tasksJson[toNumber(k)] = seqToArray(v).map(x => toNumber(x));
    }
  }
  const __taskDataJson = {};
  if (value.dtor_taskData && value.dtor_taskData.Keys) {
    for (const k of value.dtor_taskData.Keys.Elements) {
      const v = value.dtor_taskData.get(k);
      __taskDataJson[toNumber(k)] = taskToJson(v);
    }
  }
  const __tagsJson = {};
  if (value.dtor_tags && value.dtor_tags.Keys) {
    for (const k of value.dtor_tags.Keys.Elements) {
      const v = value.dtor_tags.get(k);
      __tagsJson[toNumber(k)] = tagToJson(v);
    }
  }
  return {
    mode: projectmodeToJson(value.dtor_mode),
    owner: dafnyStringToJs(value.dtor_owner),
    members: Array.from(value.dtor_members.Elements).map(x => dafnyStringToJs(x)),
    lists: seqToArray(value.dtor_lists).map(x => toNumber(x)),
    listNames: __listNamesJson,
    tasks: __tasksJson,
    taskData: __taskDataJson,
    tags: __tagsJson,
    nextListId: toNumber(value.dtor_nextListId),
    nextTaskId: toNumber(value.dtor_nextTaskId),
    nextTagId: toNumber(value.dtor_nextTagId)
  };
};

const errFromJson = (json) => {
  switch (json) {
    case 'MissingList':
      return TodoDomain.Err.create_MissingList();
    case 'MissingTask':
      return TodoDomain.Err.create_MissingTask();
    case 'MissingTag':
      return TodoDomain.Err.create_MissingTag();
    case 'MissingUser':
      return TodoDomain.Err.create_MissingUser();
    case 'DuplicateList':
      return TodoDomain.Err.create_DuplicateList();
    case 'DuplicateTask':
      return TodoDomain.Err.create_DuplicateTask();
    case 'DuplicateTag':
      return TodoDomain.Err.create_DuplicateTag();
    case 'BadAnchor':
      return TodoDomain.Err.create_BadAnchor();
    case 'NotAMember':
      return TodoDomain.Err.create_NotAMember();
    case 'PersonalProject':
      return TodoDomain.Err.create_PersonalProject();
    case 'AlreadyCollaborative':
      return TodoDomain.Err.create_AlreadyCollaborative();
    case 'CannotRemoveOwner':
      return TodoDomain.Err.create_CannotRemoveOwner();
    case 'TaskDeleted':
      return TodoDomain.Err.create_TaskDeleted();
    case 'InvalidDate':
      return TodoDomain.Err.create_InvalidDate();
    case 'Rejected':
      return TodoDomain.Err.create_Rejected();
    default:
      throw new Error(`Unknown Err: ${json}`);
  }
};

const errToJson = (value) => {
  if (value.is_MissingList) {
    return 'MissingList';
  } else if (value.is_MissingTask) {
    return 'MissingTask';
  } else if (value.is_MissingTag) {
    return 'MissingTag';
  } else if (value.is_MissingUser) {
    return 'MissingUser';
  } else if (value.is_DuplicateList) {
    return 'DuplicateList';
  } else if (value.is_DuplicateTask) {
    return 'DuplicateTask';
  } else if (value.is_DuplicateTag) {
    return 'DuplicateTag';
  } else if (value.is_BadAnchor) {
    return 'BadAnchor';
  } else if (value.is_NotAMember) {
    return 'NotAMember';
  } else if (value.is_PersonalProject) {
    return 'PersonalProject';
  } else if (value.is_AlreadyCollaborative) {
    return 'AlreadyCollaborative';
  } else if (value.is_CannotRemoveOwner) {
    return 'CannotRemoveOwner';
  } else if (value.is_TaskDeleted) {
    return 'TaskDeleted';
  } else if (value.is_InvalidDate) {
    return 'InvalidDate';
  } else if (value.is_Rejected) {
    return 'Rejected';
  }
  return 'Unknown';
};

const placeFromJson = (json) => {
  switch (json.type) {
    case 'AtEnd': {
      return TodoDomain.Place.create_AtEnd();
    }
    case 'Before': {
      return TodoDomain.Place.create_Before(
        new BigNumber(json.anchor)
      );
    }
    case 'After': {
      return TodoDomain.Place.create_After(
        new BigNumber(json.anchor)
      );
    }
    default:
      throw new Error(`Unknown Place type: ${json.type}`);
  }
};

const placeToJson = (value) => {
  if (value.is_AtEnd) {
    return { type: 'AtEnd' };
  } else if (value.is_Before) {
    return {
      type: 'Before',
      anchor: toNumber(value.dtor_anchor)
    };
  } else if (value.is_After) {
    return {
      type: 'After',
      anchor: toNumber(value.dtor_anchor)
    };
  }
  return { type: 'Unknown' };
};

const listplaceFromJson = (json) => {
  switch (json.type) {
    case 'ListAtEnd': {
      return TodoDomain.ListPlace.create_ListAtEnd();
    }
    case 'ListBefore': {
      return TodoDomain.ListPlace.create_ListBefore(
        new BigNumber(json.anchor)
      );
    }
    case 'ListAfter': {
      return TodoDomain.ListPlace.create_ListAfter(
        new BigNumber(json.anchor)
      );
    }
    default:
      throw new Error(`Unknown ListPlace type: ${json.type}`);
  }
};

const listplaceToJson = (value) => {
  if (value.is_ListAtEnd) {
    return { type: 'ListAtEnd' };
  } else if (value.is_ListBefore) {
    return {
      type: 'ListBefore',
      anchor: toNumber(value.dtor_anchor)
    };
  } else if (value.is_ListAfter) {
    return {
      type: 'ListAfter',
      anchor: toNumber(value.dtor_anchor)
    };
  }
  return { type: 'Unknown' };
};

const actionFromJson = (json) => {
  switch (json.type) {
    case 'NoOp': {
      return TodoDomain.Action.create_NoOp();
    }
    case 'AddList': {
      return TodoDomain.Action.create_AddList(
        _dafny.Seq.UnicodeFromString(json.name)
      );
    }
    case 'RenameList': {
      return TodoDomain.Action.create_RenameList(
        new BigNumber(json.listId),
        _dafny.Seq.UnicodeFromString(json.newName)
      );
    }
    case 'DeleteList': {
      return TodoDomain.Action.create_DeleteList(
        new BigNumber(json.listId)
      );
    }
    case 'MoveList': {
      return TodoDomain.Action.create_MoveList(
        new BigNumber(json.listId),
        listplaceFromJson(json.listPlace)
      );
    }
    case 'AddTask': {
      return TodoDomain.Action.create_AddTask(
        new BigNumber(json.listId),
        _dafny.Seq.UnicodeFromString(json.title)
      );
    }
    case 'EditTask': {
      return TodoDomain.Action.create_EditTask(
        new BigNumber(json.taskId),
        _dafny.Seq.UnicodeFromString(json.title),
        _dafny.Seq.UnicodeFromString(json.notes)
      );
    }
    case 'DeleteTask': {
      return TodoDomain.Action.create_DeleteTask(
        new BigNumber(json.taskId),
        _dafny.Seq.UnicodeFromString(json.userId)
      );
    }
    case 'RestoreTask': {
      return TodoDomain.Action.create_RestoreTask(
        new BigNumber(json.taskId)
      );
    }
    case 'MoveTask': {
      return TodoDomain.Action.create_MoveTask(
        new BigNumber(json.taskId),
        new BigNumber(json.toList),
        placeFromJson(json.taskPlace)
      );
    }
    case 'CompleteTask': {
      return TodoDomain.Action.create_CompleteTask(
        new BigNumber(json.taskId)
      );
    }
    case 'UncompleteTask': {
      return TodoDomain.Action.create_UncompleteTask(
        new BigNumber(json.taskId)
      );
    }
    case 'StarTask': {
      return TodoDomain.Action.create_StarTask(
        new BigNumber(json.taskId)
      );
    }
    case 'UnstarTask': {
      return TodoDomain.Action.create_UnstarTask(
        new BigNumber(json.taskId)
      );
    }
    case 'SetDueDate': {
      return TodoDomain.Action.create_SetDueDate(
        new BigNumber(json.taskId),
        optionFromJson(json.dueDate, dateFromJson)
      );
    }
    case 'AssignTask': {
      return TodoDomain.Action.create_AssignTask(
        new BigNumber(json.taskId),
        _dafny.Seq.UnicodeFromString(json.userId)
      );
    }
    case 'UnassignTask': {
      return TodoDomain.Action.create_UnassignTask(
        new BigNumber(json.taskId),
        _dafny.Seq.UnicodeFromString(json.userId)
      );
    }
    case 'AddTagToTask': {
      return TodoDomain.Action.create_AddTagToTask(
        new BigNumber(json.taskId),
        new BigNumber(json.tagId)
      );
    }
    case 'RemoveTagFromTask': {
      return TodoDomain.Action.create_RemoveTagFromTask(
        new BigNumber(json.taskId),
        new BigNumber(json.tagId)
      );
    }
    case 'CreateTag': {
      return TodoDomain.Action.create_CreateTag(
        _dafny.Seq.UnicodeFromString(json.name)
      );
    }
    case 'RenameTag': {
      return TodoDomain.Action.create_RenameTag(
        new BigNumber(json.tagId),
        _dafny.Seq.UnicodeFromString(json.newName)
      );
    }
    case 'DeleteTag': {
      return TodoDomain.Action.create_DeleteTag(
        new BigNumber(json.tagId)
      );
    }
    case 'MakeCollaborative': {
      return TodoDomain.Action.create_MakeCollaborative();
    }
    case 'AddMember': {
      return TodoDomain.Action.create_AddMember(
        _dafny.Seq.UnicodeFromString(json.userId)
      );
    }
    case 'RemoveMember': {
      return TodoDomain.Action.create_RemoveMember(
        _dafny.Seq.UnicodeFromString(json.userId)
      );
    }
    default:
      throw new Error(`Unknown Action type: ${json.type}`);
  }
};

const actionToJson = (value) => {
  if (value.is_NoOp) {
    return { type: 'NoOp' };
  } else if (value.is_AddList) {
    return {
      type: 'AddList',
      name: dafnyStringToJs(value.dtor_name)
    };
  } else if (value.is_RenameList) {
    return {
      type: 'RenameList',
      listId: toNumber(value.dtor_listId),
      newName: dafnyStringToJs(value.dtor_newName)
    };
  } else if (value.is_DeleteList) {
    return {
      type: 'DeleteList',
      listId: toNumber(value.dtor_listId)
    };
  } else if (value.is_MoveList) {
    return {
      type: 'MoveList',
      listId: toNumber(value.dtor_listId),
      listPlace: listplaceToJson(value.dtor_listPlace)
    };
  } else if (value.is_AddTask) {
    return {
      type: 'AddTask',
      listId: toNumber(value.dtor_listId),
      title: dafnyStringToJs(value.dtor_title)
    };
  } else if (value.is_EditTask) {
    return {
      type: 'EditTask',
      taskId: toNumber(value.dtor_taskId),
      title: dafnyStringToJs(value.dtor_title),
      notes: dafnyStringToJs(value.dtor_notes)
    };
  } else if (value.is_DeleteTask) {
    return {
      type: 'DeleteTask',
      taskId: toNumber(value.dtor_taskId),
      userId: dafnyStringToJs(value.dtor_userId)
    };
  } else if (value.is_RestoreTask) {
    return {
      type: 'RestoreTask',
      taskId: toNumber(value.dtor_taskId)
    };
  } else if (value.is_MoveTask) {
    return {
      type: 'MoveTask',
      taskId: toNumber(value.dtor_taskId),
      toList: toNumber(value.dtor_toList),
      taskPlace: placeToJson(value.dtor_taskPlace)
    };
  } else if (value.is_CompleteTask) {
    return {
      type: 'CompleteTask',
      taskId: toNumber(value.dtor_taskId)
    };
  } else if (value.is_UncompleteTask) {
    return {
      type: 'UncompleteTask',
      taskId: toNumber(value.dtor_taskId)
    };
  } else if (value.is_StarTask) {
    return {
      type: 'StarTask',
      taskId: toNumber(value.dtor_taskId)
    };
  } else if (value.is_UnstarTask) {
    return {
      type: 'UnstarTask',
      taskId: toNumber(value.dtor_taskId)
    };
  } else if (value.is_SetDueDate) {
    return {
      type: 'SetDueDate',
      taskId: toNumber(value.dtor_taskId),
      dueDate: optionToJson(value.dtor_dueDate, dateToJson)
    };
  } else if (value.is_AssignTask) {
    return {
      type: 'AssignTask',
      taskId: toNumber(value.dtor_taskId),
      userId: dafnyStringToJs(value.dtor_userId)
    };
  } else if (value.is_UnassignTask) {
    return {
      type: 'UnassignTask',
      taskId: toNumber(value.dtor_taskId),
      userId: dafnyStringToJs(value.dtor_userId)
    };
  } else if (value.is_AddTagToTask) {
    return {
      type: 'AddTagToTask',
      taskId: toNumber(value.dtor_taskId),
      tagId: toNumber(value.dtor_tagId)
    };
  } else if (value.is_RemoveTagFromTask) {
    return {
      type: 'RemoveTagFromTask',
      taskId: toNumber(value.dtor_taskId),
      tagId: toNumber(value.dtor_tagId)
    };
  } else if (value.is_CreateTag) {
    return {
      type: 'CreateTag',
      name: dafnyStringToJs(value.dtor_name)
    };
  } else if (value.is_RenameTag) {
    return {
      type: 'RenameTag',
      tagId: toNumber(value.dtor_tagId),
      newName: dafnyStringToJs(value.dtor_newName)
    };
  } else if (value.is_DeleteTag) {
    return {
      type: 'DeleteTag',
      tagId: toNumber(value.dtor_tagId)
    };
  } else if (value.is_MakeCollaborative) {
    return { type: 'MakeCollaborative' };
  } else if (value.is_AddMember) {
    return {
      type: 'AddMember',
      userId: dafnyStringToJs(value.dtor_userId)
    };
  } else if (value.is_RemoveMember) {
    return {
      type: 'RemoveMember',
      userId: dafnyStringToJs(value.dtor_userId)
    };
  }
  return { type: 'Unknown' };
};

const viewmodeFromJson = (json) => {
  switch (json) {
    case 'SingleProject':
      return TodoDomain.ViewMode.create_SingleProject();
    case 'AllProjects':
      return TodoDomain.ViewMode.create_AllProjects();
    default:
      throw new Error(`Unknown ViewMode: ${json}`);
  }
};

const viewmodeToJson = (value) => {
  if (value.is_SingleProject) {
    return 'SingleProject';
  } else if (value.is_AllProjects) {
    return 'AllProjects';
  }
  return 'Unknown';
};

const smartlisttypeFromJson = (json) => {
  switch (json) {
    case 'Priority':
      return TodoDomain.SmartListType.create_Priority();
    case 'Logbook':
      return TodoDomain.SmartListType.create_Logbook();
    default:
      throw new Error(`Unknown SmartListType: ${json}`);
  }
};

const smartlisttypeToJson = (value) => {
  if (value.is_Priority) {
    return 'Priority';
  } else if (value.is_Logbook) {
    return 'Logbook';
  }
  return 'Unknown';
};

const multimodelFromJson = (json) => {
  let __projects = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.projects || {})) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = modelFromJson(v);
    __projects = __projects.update(key, val);
  }
  return TodoDomain.MultiModel.create_MultiModel(
    __projects
  );
};

const multimodelToJson = (value) => {
  const __projectsJson = {};
  if (value.dtor_projects && value.dtor_projects.Keys) {
    for (const k of value.dtor_projects.Keys.Elements) {
      const v = value.dtor_projects.get(k);
      __projectsJson[dafnyStringToJs(k)] = modelToJson(v);
    }
  }
  return {
    projects: __projectsJson
  };
};

const taggedtaskidFromJson = (json) => {
  return TodoDomain.TaggedTaskId.create_TaggedTaskId(
    _dafny.Seq.UnicodeFromString(json.projectId),
    new BigNumber(json.taskId)
  );
};

const taggedtaskidToJson = (value) => {
  return {
    projectId: dafnyStringToJs(value.dtor_projectId),
    taskId: toNumber(value.dtor_taskId)
  };
};

const sidebarselectionFromJson = (json) => {
  switch (json.type) {
    case 'NoSelection': {
      return TodoDomain.SidebarSelection.create_NoSelection();
    }
    case 'SmartListSelected': {
      return TodoDomain.SidebarSelection.create_SmartListSelected(
        smartlisttypeFromJson(json.smartList)
      );
    }
    case 'ProjectSelected': {
      return TodoDomain.SidebarSelection.create_ProjectSelected(
        _dafny.Seq.UnicodeFromString(json.projectId)
      );
    }
    case 'ListSelected': {
      return TodoDomain.SidebarSelection.create_ListSelected(
        _dafny.Seq.UnicodeFromString(json.projectId),
        new BigNumber(json.listId)
      );
    }
    default:
      throw new Error(`Unknown SidebarSelection type: ${json.type}`);
  }
};

const sidebarselectionToJson = (value) => {
  if (value.is_NoSelection) {
    return { type: 'NoSelection' };
  } else if (value.is_SmartListSelected) {
    return {
      type: 'SmartListSelected',
      smartList: smartlisttypeToJson(value.dtor_smartList)
    };
  } else if (value.is_ProjectSelected) {
    return {
      type: 'ProjectSelected',
      projectId: dafnyStringToJs(value.dtor_projectId)
    };
  } else if (value.is_ListSelected) {
    return {
      type: 'ListSelected',
      projectId: dafnyStringToJs(value.dtor_projectId),
      listId: toNumber(value.dtor_listId)
    };
  }
  return { type: 'Unknown' };
};

const viewstateFromJson = (json) => {
  return TodoDomain.ViewState.create_ViewState(
    viewmodeFromJson(json.viewMode),
    sidebarselectionFromJson(json.selection),
    multimodelFromJson(json.loadedProjects)
  );
};

const viewstateToJson = (value) => {
  return {
    viewMode: viewmodeToJson(value.dtor_viewMode),
    selection: sidebarselectionToJson(value.dtor_selection),
    loadedProjects: multimodelToJson(value.dtor_loadedProjects)
  };
};

const resultFromJson = (json, T_fromJson, E_fromJson) => {
  switch (json.type) {
    case 'Ok': {
      return TodoDomain.Result.create_Ok(
        T_fromJson(json.value)
      );
    }
    case 'Err': {
      return TodoDomain.Result.create_Err(
        E_fromJson(json.error)
      );
    }
    default:
      throw new Error(`Unknown Result type: ${json.type}`);
  }
};

const resultToJson = (value, T_toJson, E_toJson) => {
  if (value.is_Ok) {
    return {
      type: 'Ok',
      value: T_toJson(value.dtor_value)
    };
  } else if (value.is_Err) {
    return {
      type: 'Err',
      error: E_toJson(value.dtor_error)
    };
  }
  return { type: 'Unknown' };
};

const multiactionFromJson = (json) => {
  switch (json.type) {
    case 'Single': {
      return TodoMultiProjectDomain.MultiAction.create_Single(
        _dafny.Seq.UnicodeFromString(json.project),
        actionFromJson(json.action)
      );
    }
    case 'MoveTaskTo': {
      return TodoMultiProjectDomain.MultiAction.create_MoveTaskTo(
        _dafny.Seq.UnicodeFromString(json.srcProject),
        _dafny.Seq.UnicodeFromString(json.dstProject),
        new BigNumber(json.taskId),
        new BigNumber(json.dstList),
        placeFromJson(json.anchor)
      );
    }
    case 'CopyTaskTo': {
      return TodoMultiProjectDomain.MultiAction.create_CopyTaskTo(
        _dafny.Seq.UnicodeFromString(json.srcProject),
        _dafny.Seq.UnicodeFromString(json.dstProject),
        new BigNumber(json.taskId),
        new BigNumber(json.dstList)
      );
    }
    default:
      throw new Error(`Unknown MultiAction type: ${json.type}`);
  }
};

const multiactionToJson = (value) => {
  if (value.is_Single) {
    return {
      type: 'Single',
      project: dafnyStringToJs(value.dtor_project),
      action: actionToJson(value.dtor_action)
    };
  } else if (value.is_MoveTaskTo) {
    return {
      type: 'MoveTaskTo',
      srcProject: dafnyStringToJs(value.dtor_srcProject),
      dstProject: dafnyStringToJs(value.dtor_dstProject),
      taskId: toNumber(value.dtor_taskId),
      dstList: toNumber(value.dtor_dstList),
      anchor: placeToJson(value.dtor_anchor)
    };
  } else if (value.is_CopyTaskTo) {
    return {
      type: 'CopyTaskTo',
      srcProject: dafnyStringToJs(value.dtor_srcProject),
      dstProject: dafnyStringToJs(value.dtor_dstProject),
      taskId: toNumber(value.dtor_taskId),
      dstList: toNumber(value.dtor_dstList)
    };
  }
  return { type: 'Unknown' };
};

const multierrFromJson = (json) => {
  switch (json.type) {
    case 'MissingProject': {
      return TodoMultiProjectDomain.MultiErr.create_MissingProject(
        _dafny.Seq.UnicodeFromString(json.projectId)
      );
    }
    case 'SingleProjectError': {
      return TodoMultiProjectDomain.MultiErr.create_SingleProjectError(
        _dafny.Seq.UnicodeFromString(json.projectId),
        errFromJson(json.err)
      );
    }
    case 'CrossProjectError': {
      return TodoMultiProjectDomain.MultiErr.create_CrossProjectError(
        _dafny.Seq.UnicodeFromString(json.message)
      );
    }
    default:
      throw new Error(`Unknown MultiErr type: ${json.type}`);
  }
};

const multierrToJson = (value) => {
  if (value.is_MissingProject) {
    return {
      type: 'MissingProject',
      projectId: dafnyStringToJs(value.dtor_projectId)
    };
  } else if (value.is_SingleProjectError) {
    return {
      type: 'SingleProjectError',
      projectId: dafnyStringToJs(value.dtor_projectId),
      err: errToJson(value.dtor_err)
    };
  } else if (value.is_CrossProjectError) {
    return {
      type: 'CrossProjectError',
      message: dafnyStringToJs(value.dtor_message)
    };
  }
  return { type: 'Unknown' };
};

const multiclientstateFromJson = (json) => {
  let __baseVersions = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.baseVersions || {})) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = new BigNumber(v);
    __baseVersions = __baseVersions.update(key, val);
  }
  return TodoMultiProjectEffectStateMachine.MultiClientState.create_MultiClientState(
    __baseVersions,
    multimodelFromJson(json.present),
    _dafny.Seq.of(...(json.pending || []).map(x => multiactionFromJson(x)))
  );
};

const multiclientstateToJson = (value) => {
  const __baseVersionsJson = {};
  if (value.dtor_baseVersions && value.dtor_baseVersions.Keys) {
    for (const k of value.dtor_baseVersions.Keys.Elements) {
      const v = value.dtor_baseVersions.get(k);
      __baseVersionsJson[dafnyStringToJs(k)] = toNumber(v);
    }
  }
  return {
    baseVersions: __baseVersionsJson,
    present: multimodelToJson(value.dtor_present),
    pending: seqToArray(value.dtor_pending).map(x => multiactionToJson(x))
  };
};

const networkstatusFromJson = (json) => {
  switch (json) {
    case 'Online':
      return TodoMultiProjectEffectStateMachine.NetworkStatus.create_Online();
    case 'Offline':
      return TodoMultiProjectEffectStateMachine.NetworkStatus.create_Offline();
    default:
      throw new Error(`Unknown NetworkStatus: ${json}`);
  }
};

const networkstatusToJson = (value) => {
  if (value.is_Online) {
    return 'Online';
  } else if (value.is_Offline) {
    return 'Offline';
  }
  return 'Unknown';
};

const effectmodeFromJson = (json) => {
  switch (json.type) {
    case 'Idle': {
      return TodoMultiProjectEffectStateMachine.EffectMode.create_Idle();
    }
    case 'Dispatching': {
      return TodoMultiProjectEffectStateMachine.EffectMode.create_Dispatching(
        new BigNumber(json.retries)
      );
    }
    default:
      throw new Error(`Unknown EffectMode type: ${json.type}`);
  }
};

const effectmodeToJson = (value) => {
  if (value.is_Idle) {
    return { type: 'Idle' };
  } else if (value.is_Dispatching) {
    return {
      type: 'Dispatching',
      retries: toNumber(value.dtor_retries)
    };
  }
  return { type: 'Unknown' };
};

const effectstateFromJson = (json) => {
  return TodoMultiProjectEffectStateMachine.EffectState.create_EffectState(
    networkstatusFromJson(json.network),
    effectmodeFromJson(json.mode),
    multiclientstateFromJson(json.client)
  );
};

const effectstateToJson = (value) => {
  return {
    network: networkstatusToJson(value.dtor_network),
    mode: effectmodeToJson(value.dtor_mode),
    client: multiclientstateToJson(value.dtor_client)
  };
};

const eventFromJson = (json) => {
  switch (json.type) {
    case 'UserAction': {
      return TodoMultiProjectEffectStateMachine.Event.create_UserAction(
        multiactionFromJson(json.action)
      );
    }
    case 'DispatchAccepted': {
      let __newVersions = _dafny.Map.Empty;
      for (const [k, v] of Object.entries(json.newVersions || {})) {
        const key = _dafny.Seq.UnicodeFromString(k);
        const val = new BigNumber(v);
        __newVersions = __newVersions.update(key, val);
      }
      let __newModels = _dafny.Map.Empty;
      for (const [k, v] of Object.entries(json.newModels || {})) {
        const key = _dafny.Seq.UnicodeFromString(k);
        const val = modelFromJson(v);
        __newModels = __newModels.update(key, val);
      }
      return TodoMultiProjectEffectStateMachine.Event.create_DispatchAccepted(
        __newVersions,
        __newModels
      );
    }
    case 'DispatchConflict': {
      let __freshVersions = _dafny.Map.Empty;
      for (const [k, v] of Object.entries(json.freshVersions || {})) {
        const key = _dafny.Seq.UnicodeFromString(k);
        const val = new BigNumber(v);
        __freshVersions = __freshVersions.update(key, val);
      }
      let __freshModels = _dafny.Map.Empty;
      for (const [k, v] of Object.entries(json.freshModels || {})) {
        const key = _dafny.Seq.UnicodeFromString(k);
        const val = modelFromJson(v);
        __freshModels = __freshModels.update(key, val);
      }
      return TodoMultiProjectEffectStateMachine.Event.create_DispatchConflict(
        __freshVersions,
        __freshModels
      );
    }
    case 'DispatchRejected': {
      let __freshVersions = _dafny.Map.Empty;
      for (const [k, v] of Object.entries(json.freshVersions || {})) {
        const key = _dafny.Seq.UnicodeFromString(k);
        const val = new BigNumber(v);
        __freshVersions = __freshVersions.update(key, val);
      }
      let __freshModels = _dafny.Map.Empty;
      for (const [k, v] of Object.entries(json.freshModels || {})) {
        const key = _dafny.Seq.UnicodeFromString(k);
        const val = modelFromJson(v);
        __freshModels = __freshModels.update(key, val);
      }
      return TodoMultiProjectEffectStateMachine.Event.create_DispatchRejected(
        __freshVersions,
        __freshModels
      );
    }
    case 'NetworkError': {
      return TodoMultiProjectEffectStateMachine.Event.create_NetworkError();
    }
    case 'NetworkRestored': {
      return TodoMultiProjectEffectStateMachine.Event.create_NetworkRestored();
    }
    case 'ManualGoOffline': {
      return TodoMultiProjectEffectStateMachine.Event.create_ManualGoOffline();
    }
    case 'ManualGoOnline': {
      return TodoMultiProjectEffectStateMachine.Event.create_ManualGoOnline();
    }
    case 'Tick': {
      return TodoMultiProjectEffectStateMachine.Event.create_Tick();
    }
    default:
      throw new Error(`Unknown Event type: ${json.type}`);
  }
};

const eventToJson = (value) => {
  if (value.is_UserAction) {
    return {
      type: 'UserAction',
      action: multiactionToJson(value.dtor_action)
    };
  } else if (value.is_DispatchAccepted) {
    const __newVersionsJson = {};
    if (value.dtor_newVersions && value.dtor_newVersions.Keys) {
      for (const k of value.dtor_newVersions.Keys.Elements) {
        const v = value.dtor_newVersions.get(k);
        __newVersionsJson[dafnyStringToJs(k)] = toNumber(v);
      }
    }
    const __newModelsJson = {};
    if (value.dtor_newModels && value.dtor_newModels.Keys) {
      for (const k of value.dtor_newModels.Keys.Elements) {
        const v = value.dtor_newModels.get(k);
        __newModelsJson[dafnyStringToJs(k)] = modelToJson(v);
      }
    }
    return {
      type: 'DispatchAccepted',
      newVersions: __newVersionsJson,
      newModels: __newModelsJson
    };
  } else if (value.is_DispatchConflict) {
    const __freshVersionsJson = {};
    if (value.dtor_freshVersions && value.dtor_freshVersions.Keys) {
      for (const k of value.dtor_freshVersions.Keys.Elements) {
        const v = value.dtor_freshVersions.get(k);
        __freshVersionsJson[dafnyStringToJs(k)] = toNumber(v);
      }
    }
    const __freshModelsJson = {};
    if (value.dtor_freshModels && value.dtor_freshModels.Keys) {
      for (const k of value.dtor_freshModels.Keys.Elements) {
        const v = value.dtor_freshModels.get(k);
        __freshModelsJson[dafnyStringToJs(k)] = modelToJson(v);
      }
    }
    return {
      type: 'DispatchConflict',
      freshVersions: __freshVersionsJson,
      freshModels: __freshModelsJson
    };
  } else if (value.is_DispatchRejected) {
    const __freshVersionsJson = {};
    if (value.dtor_freshVersions && value.dtor_freshVersions.Keys) {
      for (const k of value.dtor_freshVersions.Keys.Elements) {
        const v = value.dtor_freshVersions.get(k);
        __freshVersionsJson[dafnyStringToJs(k)] = toNumber(v);
      }
    }
    const __freshModelsJson = {};
    if (value.dtor_freshModels && value.dtor_freshModels.Keys) {
      for (const k of value.dtor_freshModels.Keys.Elements) {
        const v = value.dtor_freshModels.get(k);
        __freshModelsJson[dafnyStringToJs(k)] = modelToJson(v);
      }
    }
    return {
      type: 'DispatchRejected',
      freshVersions: __freshVersionsJson,
      freshModels: __freshModelsJson
    };
  } else if (value.is_NetworkError) {
    return { type: 'NetworkError' };
  } else if (value.is_NetworkRestored) {
    return { type: 'NetworkRestored' };
  } else if (value.is_ManualGoOffline) {
    return { type: 'ManualGoOffline' };
  } else if (value.is_ManualGoOnline) {
    return { type: 'ManualGoOnline' };
  } else if (value.is_Tick) {
    return { type: 'Tick' };
  }
  return { type: 'Unknown' };
};

const commandFromJson = (json) => {
  switch (json.type) {
    case 'NoOp': {
      return TodoMultiProjectEffectStateMachine.Command.create_NoOp();
    }
    case 'SendDispatch': {
      let __baseVersions = _dafny.Map.Empty;
      for (const [k, v] of Object.entries(json.baseVersions || {})) {
        const key = _dafny.Seq.UnicodeFromString(k);
        const val = new BigNumber(v);
        __baseVersions = __baseVersions.update(key, val);
      }
      return TodoMultiProjectEffectStateMachine.Command.create_SendDispatch(
        _dafny.Set.fromElements(...(json.touchedProjects || []).map(x => _dafny.Seq.UnicodeFromString(x))),
        __baseVersions,
        multiactionFromJson(json.action)
      );
    }
    case 'FetchFreshState': {
      return TodoMultiProjectEffectStateMachine.Command.create_FetchFreshState(
        _dafny.Set.fromElements(...(json.projects || []).map(x => _dafny.Seq.UnicodeFromString(x)))
      );
    }
    default:
      throw new Error(`Unknown Command type: ${json.type}`);
  }
};

const commandToJson = (value) => {
  if (value.is_NoOp) {
    return { type: 'NoOp' };
  } else if (value.is_SendDispatch) {
    const __baseVersionsJson = {};
    if (value.dtor_baseVersions && value.dtor_baseVersions.Keys) {
      for (const k of value.dtor_baseVersions.Keys.Elements) {
        const v = value.dtor_baseVersions.get(k);
        __baseVersionsJson[dafnyStringToJs(k)] = toNumber(v);
      }
    }
    return {
      type: 'SendDispatch',
      touchedProjects: Array.from(value.dtor_touchedProjects.Elements).map(x => dafnyStringToJs(x)),
      baseVersions: __baseVersionsJson,
      action: multiactionToJson(value.dtor_action)
    };
  } else if (value.is_FetchFreshState) {
    return {
      type: 'FetchFreshState',
      projects: Array.from(value.dtor_projects.Elements).map(x => dafnyStringToJs(x))
    };
  }
  return { type: 'Unknown' };
};

// ============================================================================
// API Wrapper
// ============================================================================

const App = {
  // Option constructors
  None: () => TodoDomain.Option.create_None(),
  Some: (value) => TodoDomain.Option.create_Some(value),

  // Date constructors
  Date: (year, month, day) => TodoDomain.Date.create_Date(new BigNumber(year), new BigNumber(month), new BigNumber(day)),

  // Task constructors
  Task: (title, notes, completed, starred, dueDate, assignees, tags, deleted, deletedBy, deletedFromList) => TodoDomain.Task.create_Task(_dafny.Seq.UnicodeFromString(title), _dafny.Seq.UnicodeFromString(notes), completed, starred, optionFromJson(dueDate, dateFromJson), _dafny.Set.fromElements(...(assignees || []).map(x => _dafny.Seq.UnicodeFromString(x))), _dafny.Set.fromElements(...(tags || []).map(x => new BigNumber(x))), deleted, optionFromJson(deletedBy, (x) => _dafny.Seq.UnicodeFromString(x)), optionFromJson(deletedFromList, (x) => new BigNumber(x))),

  // Tag constructors
  Tag: (name) => TodoDomain.Tag.create_Tag(_dafny.Seq.UnicodeFromString(name)),

  // ProjectMode constructors
  Personal: () => TodoDomain.ProjectMode.create_Personal(),
  Collaborative: () => TodoDomain.ProjectMode.create_Collaborative(),

  // Err constructors
  MissingList: () => TodoDomain.Err.create_MissingList(),
  MissingTask: () => TodoDomain.Err.create_MissingTask(),
  MissingTag: () => TodoDomain.Err.create_MissingTag(),
  MissingUser: () => TodoDomain.Err.create_MissingUser(),
  DuplicateList: () => TodoDomain.Err.create_DuplicateList(),
  DuplicateTask: () => TodoDomain.Err.create_DuplicateTask(),
  DuplicateTag: () => TodoDomain.Err.create_DuplicateTag(),
  BadAnchor: () => TodoDomain.Err.create_BadAnchor(),
  NotAMember: () => TodoDomain.Err.create_NotAMember(),
  PersonalProject: () => TodoDomain.Err.create_PersonalProject(),
  AlreadyCollaborative: () => TodoDomain.Err.create_AlreadyCollaborative(),
  CannotRemoveOwner: () => TodoDomain.Err.create_CannotRemoveOwner(),
  TaskDeleted: () => TodoDomain.Err.create_TaskDeleted(),
  InvalidDate: () => TodoDomain.Err.create_InvalidDate(),
  Rejected: () => TodoDomain.Err.create_Rejected(),

  // Place constructors
  AtEnd: () => TodoDomain.Place.create_AtEnd(),
  Before: (anchor) => TodoDomain.Place.create_Before(new BigNumber(anchor)),
  After: (anchor) => TodoDomain.Place.create_After(new BigNumber(anchor)),

  // ListPlace constructors
  ListAtEnd: () => TodoDomain.ListPlace.create_ListAtEnd(),
  ListBefore: (anchor) => TodoDomain.ListPlace.create_ListBefore(new BigNumber(anchor)),
  ListAfter: (anchor) => TodoDomain.ListPlace.create_ListAfter(new BigNumber(anchor)),

  // ViewMode constructors
  SingleProject: () => TodoDomain.ViewMode.create_SingleProject(),
  AllProjects: () => TodoDomain.ViewMode.create_AllProjects(),

  // SmartListType constructors
  Priority: () => TodoDomain.SmartListType.create_Priority(),
  Logbook: () => TodoDomain.SmartListType.create_Logbook(),

  // MultiModel constructors
  MultiModel: (projects) => TodoDomain.MultiModel.create_MultiModel(((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), modelFromJson(v)); } return m; })(projects)),

  // TaggedTaskId constructors
  TaggedTaskId: (projectId, taskId) => TodoDomain.TaggedTaskId.create_TaggedTaskId(_dafny.Seq.UnicodeFromString(projectId), new BigNumber(taskId)),

  // SidebarSelection constructors
  NoSelection: () => TodoDomain.SidebarSelection.create_NoSelection(),
  SmartListSelected: (smartList) => TodoDomain.SidebarSelection.create_SmartListSelected(smartlisttypeFromJson(smartList)),
  ProjectSelected: (projectId) => TodoDomain.SidebarSelection.create_ProjectSelected(_dafny.Seq.UnicodeFromString(projectId)),
  ListSelected: (projectId, listId) => TodoDomain.SidebarSelection.create_ListSelected(_dafny.Seq.UnicodeFromString(projectId), new BigNumber(listId)),

  // ViewState constructors
  ViewState: (viewMode, selection, loadedProjects) => TodoDomain.ViewState.create_ViewState(viewmodeFromJson(viewMode), sidebarselectionFromJson(selection), multimodelFromJson(loadedProjects)),

  // Result constructors
  Ok: (value) => TodoDomain.Result.create_Ok(value),
  Err: (error) => TodoDomain.Result.create_Err(error),

  // Action constructors
  NoOp: () => TodoDomain.Action.create_NoOp(),
  AddList: (name) => TodoDomain.Action.create_AddList(_dafny.Seq.UnicodeFromString(name)),
  RenameList: (listId, newName) => TodoDomain.Action.create_RenameList(new BigNumber(listId), _dafny.Seq.UnicodeFromString(newName)),
  DeleteList: (listId) => TodoDomain.Action.create_DeleteList(new BigNumber(listId)),
  MoveList: (listId, listPlace) => TodoDomain.Action.create_MoveList(new BigNumber(listId), listPlace),
  AddTask: (listId, title) => TodoDomain.Action.create_AddTask(new BigNumber(listId), _dafny.Seq.UnicodeFromString(title)),
  EditTask: (taskId, title, notes) => TodoDomain.Action.create_EditTask(new BigNumber(taskId), _dafny.Seq.UnicodeFromString(title), _dafny.Seq.UnicodeFromString(notes)),
  DeleteTask: (taskId, userId) => TodoDomain.Action.create_DeleteTask(new BigNumber(taskId), _dafny.Seq.UnicodeFromString(userId)),
  RestoreTask: (taskId) => TodoDomain.Action.create_RestoreTask(new BigNumber(taskId)),
  MoveTask: (taskId, toList, taskPlace) => TodoDomain.Action.create_MoveTask(new BigNumber(taskId), new BigNumber(toList), taskPlace),
  CompleteTask: (taskId) => TodoDomain.Action.create_CompleteTask(new BigNumber(taskId)),
  UncompleteTask: (taskId) => TodoDomain.Action.create_UncompleteTask(new BigNumber(taskId)),
  StarTask: (taskId) => TodoDomain.Action.create_StarTask(new BigNumber(taskId)),
  UnstarTask: (taskId) => TodoDomain.Action.create_UnstarTask(new BigNumber(taskId)),
  SetDueDate: (taskId, dueDate) => TodoDomain.Action.create_SetDueDate(new BigNumber(taskId), dueDate),
  AssignTask: (taskId, userId) => TodoDomain.Action.create_AssignTask(new BigNumber(taskId), _dafny.Seq.UnicodeFromString(userId)),
  UnassignTask: (taskId, userId) => TodoDomain.Action.create_UnassignTask(new BigNumber(taskId), _dafny.Seq.UnicodeFromString(userId)),
  AddTagToTask: (taskId, tagId) => TodoDomain.Action.create_AddTagToTask(new BigNumber(taskId), new BigNumber(tagId)),
  RemoveTagFromTask: (taskId, tagId) => TodoDomain.Action.create_RemoveTagFromTask(new BigNumber(taskId), new BigNumber(tagId)),
  CreateTag: (name) => TodoDomain.Action.create_CreateTag(_dafny.Seq.UnicodeFromString(name)),
  RenameTag: (tagId, newName) => TodoDomain.Action.create_RenameTag(new BigNumber(tagId), _dafny.Seq.UnicodeFromString(newName)),
  DeleteTag: (tagId) => TodoDomain.Action.create_DeleteTag(new BigNumber(tagId)),
  MakeCollaborative: () => TodoDomain.Action.create_MakeCollaborative(),
  AddMember: (userId) => TodoDomain.Action.create_AddMember(_dafny.Seq.UnicodeFromString(userId)),
  RemoveMember: (userId) => TodoDomain.Action.create_RemoveMember(_dafny.Seq.UnicodeFromString(userId)),

  // Model accessors
  GetMode: (m) => projectmodeToJson(m.dtor_mode),
  GetOwner: (m) => dafnyStringToJs(m.dtor_owner),
  GetMembers: (m) => Array.from(m.dtor_members.Elements).map(x => dafnyStringToJs(x)),
  GetLists: (m) => seqToArray(m.dtor_lists).map(x => toNumber(x)),
  GetListNames: (m, key) => {
    const dafnyKey = new BigNumber(key);
    if (m.dtor_listNames.contains(dafnyKey)) {
      const val = m.dtor_listNames.get(dafnyKey);
      return dafnyStringToJs(val);
    }
    return null;
  },
  GetTasks: (m, key) => {
    const dafnyKey = new BigNumber(key);
    if (m.dtor_tasks.contains(dafnyKey)) {
      const val = m.dtor_tasks.get(dafnyKey);
      return seqToArray(val).map(x => toNumber(x));
    }
    return null;
  },
  GetTaskData: (m, key) => {
    const dafnyKey = new BigNumber(key);
    if (m.dtor_taskData.contains(dafnyKey)) {
      const val = m.dtor_taskData.get(dafnyKey);
      return taskToJson(val);
    }
    return null;
  },
  GetTags: (m, key) => {
    const dafnyKey = new BigNumber(key);
    if (m.dtor_tags.contains(dafnyKey)) {
      const val = m.dtor_tags.get(dafnyKey);
      return tagToJson(val);
    }
    return null;
  },
  GetNextListId: (m) => toNumber(m.dtor_nextListId),
  GetNextTaskId: (m) => toNumber(m.dtor_nextTaskId),
  GetNextTagId: (m) => toNumber(m.dtor_nextTagId),

  // AppCore functions
  EffectInit: (versions, models) => TodoMultiProjectEffectAppCore.__default.EffectInit(((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(versions), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), modelFromJson(v)); } return m; })(models)),
  EffectStep: (es, event) => TodoMultiProjectEffectAppCore.__default.EffectStep(es, event),
  EffectIsOnline: (es) => TodoMultiProjectEffectAppCore.__default.EffectIsOnline(es),
  EffectIsIdle: (es) => TodoMultiProjectEffectAppCore.__default.EffectIsIdle(es),
  EffectHasPending: (es) => TodoMultiProjectEffectAppCore.__default.EffectHasPending(es),
  EffectPendingCount: (es) => toNumber(TodoMultiProjectEffectAppCore.__default.EffectPendingCount(es)),
  EffectIsDispatching: (es) => TodoMultiProjectEffectAppCore.__default.EffectIsDispatching(es),
  EffectGetClient: (es) => TodoMultiProjectEffectAppCore.__default.EffectGetClient(es),
  EffectGetMultiModel: (es) => TodoMultiProjectEffectAppCore.__default.EffectGetMultiModel(es),
  EffectGetBaseVersions: (es) => TodoMultiProjectEffectAppCore.__default.EffectGetBaseVersions(es),
  EffectGetPending: (es) => seqToArray(TodoMultiProjectEffectAppCore.__default.EffectGetPending(es)).map(x => multiactionToJson(x)),
  EffectUserAction: (action) => TodoMultiProjectEffectAppCore.__default.EffectUserAction(action),
  EffectSingleUserAction: (projectId, action) => TodoMultiProjectEffectAppCore.__default.EffectSingleUserAction(_dafny.Seq.UnicodeFromString(projectId), action),
  EffectDispatchAccepted: (newVersions, newModels) => TodoMultiProjectEffectAppCore.__default.EffectDispatchAccepted(((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(newVersions), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), modelFromJson(v)); } return m; })(newModels)),
  EffectDispatchConflict: (freshVersions, freshModels) => TodoMultiProjectEffectAppCore.__default.EffectDispatchConflict(((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(freshVersions), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), modelFromJson(v)); } return m; })(freshModels)),
  EffectDispatchRejected: (freshVersions, freshModels) => TodoMultiProjectEffectAppCore.__default.EffectDispatchRejected(((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(freshVersions), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), modelFromJson(v)); } return m; })(freshModels)),
  EffectNetworkError: () => TodoMultiProjectEffectAppCore.__default.EffectNetworkError(),
  EffectNetworkRestored: () => TodoMultiProjectEffectAppCore.__default.EffectNetworkRestored(),
  EffectManualGoOffline: () => TodoMultiProjectEffectAppCore.__default.EffectManualGoOffline(),
  EffectManualGoOnline: () => TodoMultiProjectEffectAppCore.__default.EffectManualGoOnline(),
  EffectTick: () => TodoMultiProjectEffectAppCore.__default.EffectTick(),
  EffectIsNoOp: (cmd) => TodoMultiProjectEffectAppCore.__default.EffectIsNoOp(cmd),
  EffectIsSendDispatch: (cmd) => TodoMultiProjectEffectAppCore.__default.EffectIsSendDispatch(cmd),
  EffectIsFetchFreshState: (cmd) => TodoMultiProjectEffectAppCore.__default.EffectIsFetchFreshState(cmd),
  EffectGetTouchedProjects: (cmd) => TodoMultiProjectEffectAppCore.__default.EffectGetTouchedProjects(cmd),
  EffectGetBaseVersionsFromCmd: (cmd) => TodoMultiProjectEffectAppCore.__default.EffectGetBaseVersionsFromCmd(cmd),
  EffectGetMultiAction: (cmd) => TodoMultiProjectEffectAppCore.__default.EffectGetMultiAction(cmd),
  MakeSingleAction: (projectId, action) => TodoMultiProjectEffectAppCore.__default.MakeSingleAction(_dafny.Seq.UnicodeFromString(projectId), action),
  MakeMoveTaskTo: (srcProject, dstProject, taskId, dstList, anchor) => TodoMultiProjectEffectAppCore.__default.MakeMoveTaskTo(_dafny.Seq.UnicodeFromString(srcProject), _dafny.Seq.UnicodeFromString(dstProject), new BigNumber(taskId), new BigNumber(dstList), anchor),
  MakeCopyTaskTo: (srcProject, dstProject, taskId, dstList) => TodoMultiProjectEffectAppCore.__default.MakeCopyTaskTo(_dafny.Seq.UnicodeFromString(srcProject), _dafny.Seq.UnicodeFromString(dstProject), new BigNumber(taskId), new BigNumber(dstList)),
  IsSingleAction: (ma) => TodoMultiProjectEffectAppCore.__default.IsSingleAction(ma),
  IsMoveTaskTo: (ma) => TodoMultiProjectEffectAppCore.__default.IsMoveTaskTo(ma),
  IsCopyTaskTo: (ma) => TodoMultiProjectEffectAppCore.__default.IsCopyTaskTo(ma),
  GetTouchedProjects: (ma) => TodoMultiProjectEffectAppCore.__default.GetTouchedProjects(ma),
  GetProjectModel: (mm, projectId) => TodoMultiProjectEffectAppCore.__default.GetProjectModel(mm, _dafny.Seq.UnicodeFromString(projectId)),
  HasProject: (mm, projectId) => TodoMultiProjectEffectAppCore.__default.HasProject(mm, _dafny.Seq.UnicodeFromString(projectId)),
  GetProjectIds: (mm) => TodoMultiProjectEffectAppCore.__default.GetProjectIds(mm),
  TryMultiStep: (mm, action) => TodoMultiProjectEffectAppCore.__default.TryMultiStep(mm, action),
  MultiRebase: (projectLogs, baseVersions, action) => TodoMultiProjectEffectAppCore.__default.MultiRebase(((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), _dafny.Seq.of(...(v || []).map(x => actionFromJson(x)))); } return m; })(projectLogs), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(baseVersions), action),
  MultiCandidates: (mm, action) => seqToArray(TodoMultiProjectEffectAppCore.__default.MultiCandidates(mm, action)).map(x => multiactionToJson(x)),

  // Conversion functions
  optionToJson: optionToJson,
  optionFromJson: optionFromJson,
  dateToJson: dateToJson,
  dateFromJson: dateFromJson,
  taskToJson: taskToJson,
  taskFromJson: taskFromJson,
  tagToJson: tagToJson,
  tagFromJson: tagFromJson,
  projectmodeToJson: projectmodeToJson,
  projectmodeFromJson: projectmodeFromJson,
  modelToJson: modelToJson,
  modelFromJson: modelFromJson,
  errToJson: errToJson,
  errFromJson: errFromJson,
  placeToJson: placeToJson,
  placeFromJson: placeFromJson,
  listplaceToJson: listplaceToJson,
  listplaceFromJson: listplaceFromJson,
  actionToJson: actionToJson,
  actionFromJson: actionFromJson,
  viewmodeToJson: viewmodeToJson,
  viewmodeFromJson: viewmodeFromJson,
  smartlisttypeToJson: smartlisttypeToJson,
  smartlisttypeFromJson: smartlisttypeFromJson,
  multimodelToJson: multimodelToJson,
  multimodelFromJson: multimodelFromJson,
  taggedtaskidToJson: taggedtaskidToJson,
  taggedtaskidFromJson: taggedtaskidFromJson,
  sidebarselectionToJson: sidebarselectionToJson,
  sidebarselectionFromJson: sidebarselectionFromJson,
  viewstateToJson: viewstateToJson,
  viewstateFromJson: viewstateFromJson,
  resultToJson: resultToJson,
  resultFromJson: resultFromJson,
  multiactionToJson: multiactionToJson,
  multiactionFromJson: multiactionFromJson,
  multierrToJson: multierrToJson,
  multierrFromJson: multierrFromJson,
  multiclientstateToJson: multiclientstateToJson,
  multiclientstateFromJson: multiclientstateFromJson,
  networkstatusToJson: networkstatusToJson,
  networkstatusFromJson: networkstatusFromJson,
  effectmodeToJson: effectmodeToJson,
  effectmodeFromJson: effectmodeFromJson,
  effectstateToJson: effectstateToJson,
  effectstateFromJson: effectstateFromJson,
  eventToJson: eventToJson,
  eventFromJson: eventFromJson,
  commandToJson: commandToJson,
  commandFromJson: commandFromJson,
};

// Export internals for custom extensions
App._internal = { _dafny, TodoDomain, TodoMultiProjectDomain, TodoMultiProjectEffectStateMachine, TodoMultiProjectEffectAppCore };

export default App;
