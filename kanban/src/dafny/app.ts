// Generated by dafny2js
// Do not edit manually - regenerate from Dafny sources

import BigNumber from 'bignumber.js';

// Configure BigNumber as Dafny expects
BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });

// Import the generated code as raw text
import dafnyCode from './Kanban.cjs?raw';

// Set up the environment and evaluate the Dafny code
const require = (mod: string) => {
  if (mod === 'bignumber.js') return BigNumber;
  throw new Error(`Unknown module: ${mod}`);
};

// Create a function that evaluates the code with proper scope
const initDafny = new Function('require', `
  ${dafnyCode}
  return { _dafny, KanbanDomain, KanbanKernel, KanbanAppCore };
`);

const { _dafny, KanbanDomain, KanbanKernel, KanbanAppCore } = initDafny(require);

// ============================================================================
// Helpers
// ============================================================================

// deno-lint-ignore no-explicit-any
const seqToArray = (seq: any): any[] => {
  const arr = [];
  for (let i = 0; i < seq.length; i++) {
    arr.push(seq[i]);
  }
  return arr;
};

// deno-lint-ignore no-explicit-any
const toNumber = (bn: any): number => {
  if (bn && typeof bn.toNumber === 'function') {
    return bn.toNumber();
  }
  return bn;
};

// deno-lint-ignore no-explicit-any
const dafnyStringToJs = (seq: any): string => {
  if (typeof seq === 'string') return seq;
  if (seq.toVerbatimString) return seq.toVerbatimString(false);
  return Array.from(seq).join('');
};


// ============================================================================
// TypeScript Type Definitions (JSON representation)
// ============================================================================

export interface Card {
  title: string;
}

export interface Model {
  cols: string[];
  lanes: Record<string, number[]>;
  wip: Record<string, number>;
  cards: Record<string, Card>;
  nextId: number;
}

export type Action =
  | { type: 'AddColumn'; col: string; limit: number }
  | { type: 'SetWip'; col: string; limit: number }
  | { type: 'AddCard'; col: string; title: string }
  | { type: 'MoveCard'; id: number; toCol: string; pos: number };

export interface History {
  past: Model[];
  present: Model;
  future: Model[];
}

// ============================================================================
// Dafny Runtime Types (actual Dafny runtime object shapes)
// ============================================================================

// Base Dafny runtime types
type DafnyInt = InstanceType<typeof BigNumber>;
interface DafnySeq<T = unknown> {
  readonly length: number;
  readonly [index: number]: T;
  toVerbatimString?(asLiteral: boolean): string;
  map<U>(fn: (x: T) => U): U[];
}
interface DafnySet<T = unknown> { readonly Elements: Iterable<T>; }
interface DafnyMap<K = unknown, V = unknown> {
  readonly Keys: DafnySet<K>;
  get(key: K): V;
  contains(key: K): boolean;
}
type DafnyTuple2<T0, T1> = readonly [T0, T1];
type DafnyTuple3<T0, T1, T2> = readonly [T0, T1, T2];

interface DafnyCard {
  readonly is_Card: true;
  readonly dtor_title: DafnySeq;
}

interface DafnyModel {
  readonly is_Model: true;
  readonly dtor_cols: DafnySeq<DafnySeq>;
  readonly dtor_lanes: DafnyMap<DafnySeq, DafnySeq<DafnyInt>>;
  readonly dtor_wip: DafnyMap<DafnySeq, DafnyInt>;
  readonly dtor_cards: DafnyMap<DafnyInt, DafnyCard>;
  readonly dtor_nextId: DafnyInt;
}

type DafnyAction = { readonly is_AddColumn: true; readonly is_SetWip: false; readonly is_AddCard: false; readonly is_MoveCard: false; readonly dtor_col: DafnySeq; readonly dtor_limit: DafnyInt } | { readonly is_AddColumn: false; readonly is_SetWip: true; readonly is_AddCard: false; readonly is_MoveCard: false; readonly dtor_col: DafnySeq; readonly dtor_limit: DafnyInt } | { readonly is_AddColumn: false; readonly is_SetWip: false; readonly is_AddCard: true; readonly is_MoveCard: false; readonly dtor_col: DafnySeq; readonly dtor_title: DafnySeq } | { readonly is_AddColumn: false; readonly is_SetWip: false; readonly is_AddCard: false; readonly is_MoveCard: true; readonly dtor_id: DafnyInt; readonly dtor_toCol: DafnySeq; readonly dtor_pos: DafnyInt };

interface DafnyHistory {
  readonly is_History: true;
  readonly dtor_past: DafnySeq<DafnyModel>;
  readonly dtor_present: DafnyModel;
  readonly dtor_future: DafnySeq<DafnyModel>;
}

// ============================================================================
// Datatype Conversions
// ============================================================================

// deno-lint-ignore no-explicit-any
const cardFromJson = (json: any): DafnyCard => {
  return KanbanDomain.Card.create_Card(
    _dafny.Seq.UnicodeFromString(json.title)
  );
};

// deno-lint-ignore no-explicit-any
const cardToJson = (value: any): Card => {
  return {
    title: dafnyStringToJs(value.dtor_title)
  };
};

// deno-lint-ignore no-explicit-any
const modelFromJson = (json: any): DafnyModel => {
  let __lanes = _dafny.Map.Empty;
  for (const [k, v] of (Object.entries(json.lanes || {}) as [string, any][])) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = _dafny.Seq.of(...(v || []).map((x: any) => new BigNumber(x)));
    __lanes = __lanes.update(key, val);
  }
  let __wip = _dafny.Map.Empty;
  for (const [k, v] of (Object.entries(json.wip || {}) as [string, any][])) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = new BigNumber(v);
    __wip = __wip.update(key, val);
  }
  let __cards = _dafny.Map.Empty;
  for (const [k, v] of (Object.entries(json.cards || {}) as [string, any][])) {
    const key = new BigNumber(k);
    const val = cardFromJson(v);
    __cards = __cards.update(key, val);
  }
  return KanbanDomain.Model.create_Model(
    _dafny.Seq.of(...(json.cols || []).map((x: any) => _dafny.Seq.UnicodeFromString(x))),
    __lanes,
    __wip,
    __cards,
    new BigNumber(json.nextId)
  );
};

// deno-lint-ignore no-explicit-any
const modelToJson = (value: any): Model => {
  const __lanesJson: Record<string, any> = {};
  if (value.dtor_lanes && value.dtor_lanes.Keys) {
    for (const k of value.dtor_lanes.Keys.Elements) {
      const v = value.dtor_lanes.get(k);
      __lanesJson[dafnyStringToJs(k)] = seqToArray(v).map((x: any) => toNumber(x));
    }
  }
  const __wipJson: Record<string, any> = {};
  if (value.dtor_wip && value.dtor_wip.Keys) {
    for (const k of value.dtor_wip.Keys.Elements) {
      const v = value.dtor_wip.get(k);
      __wipJson[dafnyStringToJs(k)] = toNumber(v);
    }
  }
  const __cardsJson: Record<string, any> = {};
  if (value.dtor_cards && value.dtor_cards.Keys) {
    for (const k of value.dtor_cards.Keys.Elements) {
      const v = value.dtor_cards.get(k);
      __cardsJson[toNumber(k)] = cardToJson(v);
    }
  }
  return {
    cols: seqToArray(value.dtor_cols).map((x: any) => dafnyStringToJs(x)),
    lanes: __lanesJson,
    wip: __wipJson,
    cards: __cardsJson,
    nextId: toNumber(value.dtor_nextId)
  };
};

// deno-lint-ignore no-explicit-any
const actionFromJson = (json: any): DafnyAction => {
  switch (json.type) {
    case 'AddColumn': {
      return KanbanDomain.Action.create_AddColumn(
        _dafny.Seq.UnicodeFromString(json.col),
        new BigNumber(json.limit)
      );
    }
    case 'SetWip': {
      return KanbanDomain.Action.create_SetWip(
        _dafny.Seq.UnicodeFromString(json.col),
        new BigNumber(json.limit)
      );
    }
    case 'AddCard': {
      return KanbanDomain.Action.create_AddCard(
        _dafny.Seq.UnicodeFromString(json.col),
        _dafny.Seq.UnicodeFromString(json.title)
      );
    }
    case 'MoveCard': {
      return KanbanDomain.Action.create_MoveCard(
        new BigNumber(json.id),
        _dafny.Seq.UnicodeFromString(json.toCol),
        new BigNumber(json.pos)
      );
    }
    default:
      throw new Error(`Unknown Action type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const actionToJson = (value: any): Action => {
  if (value.is_AddColumn) {
    return {
      type: 'AddColumn',
      col: dafnyStringToJs(value.dtor_col),
      limit: toNumber(value.dtor_limit)
    };
  } else if (value.is_SetWip) {
    return {
      type: 'SetWip',
      col: dafnyStringToJs(value.dtor_col),
      limit: toNumber(value.dtor_limit)
    };
  } else if (value.is_AddCard) {
    return {
      type: 'AddCard',
      col: dafnyStringToJs(value.dtor_col),
      title: dafnyStringToJs(value.dtor_title)
    };
  } else if (value.is_MoveCard) {
    return {
      type: 'MoveCard',
      id: toNumber(value.dtor_id),
      toCol: dafnyStringToJs(value.dtor_toCol),
      pos: toNumber(value.dtor_pos)
    };
  }
  throw new Error('Unknown Action variant');
};

// deno-lint-ignore no-explicit-any
const historyFromJson = (json: any): DafnyHistory => {
  return KanbanKernel.History.create_History(
    _dafny.Seq.of(...(json.past || []).map((x: any) => modelFromJson(x))),
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.future || []).map((x: any) => modelFromJson(x)))
  );
};

// deno-lint-ignore no-explicit-any
const historyToJson = (value: any): History => {
  return {
    past: seqToArray(value.dtor_past).map((x: any) => modelToJson(x)),
    present: modelToJson(value.dtor_present),
    future: seqToArray(value.dtor_future).map((x: any) => modelToJson(x))
  };
};

// ============================================================================
// API Wrapper
// ============================================================================

interface AppInternal { _dafny: unknown; KanbanDomain: unknown; KanbanKernel: unknown; KanbanAppCore: unknown; }

const App = {
  // Card constructors
  Card: (title: string) => KanbanDomain.Card.create_Card(_dafny.Seq.UnicodeFromString(title)),

  // Action constructors
  AddColumn: (col: string, limit: number) => KanbanDomain.Action.create_AddColumn(_dafny.Seq.UnicodeFromString(col), new BigNumber(limit)),
  SetWip: (col: string, limit: number) => KanbanDomain.Action.create_SetWip(_dafny.Seq.UnicodeFromString(col), new BigNumber(limit)),
  AddCard: (col: string, title: string) => KanbanDomain.Action.create_AddCard(_dafny.Seq.UnicodeFromString(col), _dafny.Seq.UnicodeFromString(title)),
  MoveCard: (id: number, toCol: string, pos: number) => KanbanDomain.Action.create_MoveCard(new BigNumber(id), _dafny.Seq.UnicodeFromString(toCol), new BigNumber(pos)),

  // Model accessors
  GetCols: (m: DafnyModel) => seqToArray(m.dtor_cols).map((x: any) => dafnyStringToJs(x)),
  GetLanes: (m: DafnyModel, key: string) => {
    const dafnyKey = _dafny.Seq.UnicodeFromString(key);
    if (m.dtor_lanes.contains(dafnyKey)) {
      const val = m.dtor_lanes.get(dafnyKey);
      return seqToArray(val).map((x: any) => toNumber(x));
    }
    return null;
  },
  GetWip: (m: DafnyModel, key: string) => {
    const dafnyKey = _dafny.Seq.UnicodeFromString(key);
    if (m.dtor_wip.contains(dafnyKey)) {
      const val = m.dtor_wip.get(dafnyKey);
      return toNumber(val);
    }
    return null;
  },
  GetCards: (m: DafnyModel, key: number) => {
    const dafnyKey = new BigNumber(key);
    if (m.dtor_cards.contains(dafnyKey)) {
      const val = m.dtor_cards.get(dafnyKey);
      return cardToJson(val);
    }
    return null;
  },
  GetNextId: (m: DafnyModel) => toNumber(m.dtor_nextId),

  // AppCore functions
  Init: () => KanbanAppCore.__default.Init(),
  Dispatch: (h: DafnyHistory, a: DafnyAction) => KanbanAppCore.__default.Dispatch(h, a),
  Undo: (h: DafnyHistory) => KanbanAppCore.__default.Undo(h),
  Redo: (h: DafnyHistory) => KanbanAppCore.__default.Redo(h),
  Present: (h: DafnyHistory) => KanbanAppCore.__default.Present(h),
  CanUndo: (h: DafnyHistory) => KanbanAppCore.__default.CanUndo(h),
  CanRedo: (h: DafnyHistory) => KanbanAppCore.__default.CanRedo(h),
  GetLane: (m: DafnyModel, col: string) => seqToArray(KanbanAppCore.__default.GetLane(m, _dafny.Seq.UnicodeFromString(col))).map(x => toNumber(x)),
  GetCardTitle: (m: DafnyModel, id: number) => dafnyStringToJs(KanbanAppCore.__default.GetCardTitle(m, new BigNumber(id))),

  // Conversion functions
  cardToJson,
  cardFromJson,
  modelToJson,
  modelFromJson,
  actionToJson,
  actionFromJson,
  historyToJson,
  historyFromJson,

  // Internal modules for custom extensions
  _internal: { _dafny, KanbanDomain, KanbanKernel, KanbanAppCore } as AppInternal,
};

export default App;
