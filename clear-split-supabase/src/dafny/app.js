// Generated by dafny2js
// Do not edit manually - regenerate from Dafny sources

import BigNumber from 'bignumber.js';

// Configure BigNumber as Dafny expects
BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });

// Import the generated code as raw text
import dafnyCode from './ClearSplitEffect.cjs?raw';

// Set up the environment and evaluate the Dafny code
const require = (mod) => {
  if (mod === 'bignumber.js') return BigNumber;
  throw new Error(`Unknown module: ${mod}`);
};

// Create a function that evaluates the code with proper scope
const initDafny = new Function('require', `
  ${dafnyCode}
  return { _dafny, ClearSplit, ClearSplitMultiCollaboration, ClearSplitEffectStateMachine, ClearSplitEffectAppCore };
`);

const { _dafny, ClearSplit, ClearSplitMultiCollaboration, ClearSplitEffectStateMachine, ClearSplitEffectAppCore } = initDafny(require);


// ============================================================================
// Helpers
// ============================================================================

// Convert Dafny seq to JS array
const seqToArray = (seq) => {
  const arr = [];
  for (let i = 0; i < seq.length; i++) {
    arr.push(seq[i]);
  }
  return arr;
};

// Convert BigNumber to JS number
const toNumber = (bn) => {
  if (bn && typeof bn.toNumber === 'function') {
    return bn.toNumber();
  }
  return bn;
};

// Convert Dafny string to JS string
const dafnyStringToJs = (seq) => {
  if (typeof seq === 'string') return seq;
  if (seq.toVerbatimString) return seq.toVerbatimString(false);
  return Array.from(seq).join('');
};

// ============================================================================
// Datatype Conversions
// ============================================================================

const expenseFromJson = (json) => {
  let __shares = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.shares || {})) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = new BigNumber(v);
    __shares = __shares.update(key, val);
  }
  return ClearSplit.Expense.create_Expense(
    _dafny.Seq.UnicodeFromString(json.paidBy),
    new BigNumber(json.amount),
    __shares,
    _dafny.Seq.of(...(json.shareKeys || []).map(x => _dafny.Seq.UnicodeFromString(x)))
  );
};

const expenseToJson = (value) => {
  const __sharesJson = {};
  if (value.dtor_shares && value.dtor_shares.Keys) {
    for (const k of value.dtor_shares.Keys.Elements) {
      const v = value.dtor_shares.get(k);
      __sharesJson[dafnyStringToJs(k)] = toNumber(v);
    }
  }
  return {
    paidBy: dafnyStringToJs(value.dtor_paidBy),
    amount: toNumber(value.dtor_amount),
    shares: __sharesJson,
    shareKeys: seqToArray(value.dtor_shareKeys).map(x => dafnyStringToJs(x))
  };
};

const settlementFromJson = (json) => {
  return ClearSplit.Settlement.create_Settlement(
    _dafny.Seq.UnicodeFromString(json.from),
    _dafny.Seq.UnicodeFromString(json.to),
    new BigNumber(json.amount)
  );
};

const settlementToJson = (value) => {
  return {
    from: dafnyStringToJs(value.dtor_from),
    to: dafnyStringToJs(value.dtor_to),
    amount: toNumber(value.dtor_amount)
  };
};

const modelFromJson = (json) => {
  return ClearSplit.Model.create_Model(
    _dafny.Set.fromElements(...(json.members || []).map(x => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Seq.of(...(json.memberList || []).map(x => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Seq.of(...(json.expenses || []).map(x => expenseFromJson(x))),
    _dafny.Seq.of(...(json.settlements || []).map(x => settlementFromJson(x)))
  );
};

const modelToJson = (value) => {
  return {
    members: Array.from(value.dtor_members.Elements).map(x => dafnyStringToJs(x)),
    memberList: seqToArray(value.dtor_memberList).map(x => dafnyStringToJs(x)),
    expenses: seqToArray(value.dtor_expenses).map(x => expenseToJson(x)),
    settlements: seqToArray(value.dtor_settlements).map(x => settlementToJson(x))
  };
};

const resultFromJson = (json) => {
  switch (json.type) {
    case 'Ok':
      return ClearSplit.Result.create_Ok(
        json.value
      );
    case 'Error':
      return ClearSplit.Result.create_Error(
        json.error
      );
    default:
      throw new Error(`Unknown Result type: ${json.type}`);
  }
};

const resultToJson = (value) => {
  if (value.is_Ok) {
    return {
      type: 'Ok',
      value: value.dtor_value
    };
  } else if (value.is_Error) {
    return {
      type: 'Error',
      error: value.dtor_error
    };
  }
  return { type: 'Unknown' };
};

const errFromJson = (json) => {
  switch (json.type) {
    case 'NotMember':
      return ClearSplit.Err.create_NotMember(
        _dafny.Seq.UnicodeFromString(json.p)
      );
    case 'BadExpense':
      return ClearSplit.Err.create_BadExpense();
    case 'BadSettlement':
      return ClearSplit.Err.create_BadSettlement();
    default:
      throw new Error(`Unknown Err type: ${json.type}`);
  }
};

const errToJson = (value) => {
  if (value.is_NotMember) {
    return {
      type: 'NotMember',
      p: dafnyStringToJs(value.dtor_p)
    };
  } else if (value.is_BadExpense) {
    return { type: 'BadExpense' };
  } else if (value.is_BadSettlement) {
    return { type: 'BadSettlement' };
  }
  return { type: 'Unknown' };
};

const actionFromJson = (json) => {
  switch (json.type) {
    case 'AddExpense':
      return ClearSplit.Action.create_AddExpense(
        expenseFromJson(json.e)
      );
    case 'AddSettlement':
      return ClearSplit.Action.create_AddSettlement(
        settlementFromJson(json.s)
      );
    default:
      throw new Error(`Unknown Action type: ${json.type}`);
  }
};

const actionToJson = (value) => {
  if (value.is_AddExpense) {
    return {
      type: 'AddExpense',
      e: expenseToJson(value.dtor_e)
    };
  } else if (value.is_AddSettlement) {
    return {
      type: 'AddSettlement',
      s: settlementToJson(value.dtor_s)
    };
  }
  return { type: 'Unknown' };
};

const certificateFromJson = (json) => {
  return ClearSplit.Certificate.create_Certificate(
    new BigNumber(json.memberCount),
    new BigNumber(json.expenseCount),
    new BigNumber(json.settlementCount),
    json.conservationHolds
  );
};

const certificateToJson = (value) => {
  return {
    memberCount: toNumber(value.dtor_memberCount),
    expenseCount: toNumber(value.dtor_expenseCount),
    settlementCount: toNumber(value.dtor_settlementCount),
    conservationHolds: value.dtor_conservationHolds
  };
};

const rejectreasonFromJson = (json) => {
  return ClearSplitMultiCollaboration.RejectReason.create_DomainInvalid();
};

const rejectreasonToJson = (value) => {
  return {};
};

const replyFromJson = (json) => {
  switch (json.type) {
    case 'Accepted':
      return ClearSplitMultiCollaboration.Reply.create_Accepted(
        new BigNumber(json.newVersion),
        modelFromJson(json.newPresent),
        actionFromJson(json.applied),
        json.noChange
      );
    case 'Rejected':
      return ClearSplitMultiCollaboration.Reply.create_Rejected(
        rejectreasonFromJson(json.reason),
        actionFromJson(json.rebased)
      );
    default:
      throw new Error(`Unknown Reply type: ${json.type}`);
  }
};

const replyToJson = (value) => {
  if (value.is_Accepted) {
    return {
      type: 'Accepted',
      newVersion: toNumber(value.dtor_newVersion),
      newPresent: modelToJson(value.dtor_newPresent),
      applied: actionToJson(value.dtor_applied),
      noChange: value.dtor_noChange
    };
  } else if (value.is_Rejected) {
    return {
      type: 'Rejected',
      reason: rejectreasonToJson(value.dtor_reason),
      rebased: actionToJson(value.dtor_rebased)
    };
  }
  return { type: 'Unknown' };
};

const requestoutcomeFromJson = (json) => {
  switch (json.type) {
    case 'AuditAccepted':
      return ClearSplitMultiCollaboration.RequestOutcome.create_AuditAccepted(
        actionFromJson(json.applied),
        json.noChange
      );
    case 'AuditRejected':
      return ClearSplitMultiCollaboration.RequestOutcome.create_AuditRejected(
        rejectreasonFromJson(json.reason),
        actionFromJson(json.rebased)
      );
    default:
      throw new Error(`Unknown RequestOutcome type: ${json.type}`);
  }
};

const requestoutcomeToJson = (value) => {
  if (value.is_AuditAccepted) {
    return {
      type: 'AuditAccepted',
      applied: actionToJson(value.dtor_applied),
      noChange: value.dtor_noChange
    };
  } else if (value.is_AuditRejected) {
    return {
      type: 'AuditRejected',
      reason: rejectreasonToJson(value.dtor_reason),
      rebased: actionToJson(value.dtor_rebased)
    };
  }
  return { type: 'Unknown' };
};

const requestrecordFromJson = (json) => {
  return ClearSplitMultiCollaboration.RequestRecord.create_Req(
    new BigNumber(json.baseVersion),
    actionFromJson(json.orig),
    actionFromJson(json.rebased),
    actionFromJson(json.chosen),
    requestoutcomeFromJson(json.outcome)
  );
};

const requestrecordToJson = (value) => {
  return {
    baseVersion: toNumber(value.dtor_baseVersion),
    orig: actionToJson(value.dtor_orig),
    rebased: actionToJson(value.dtor_rebased),
    chosen: actionToJson(value.dtor_chosen),
    outcome: requestoutcomeToJson(value.dtor_outcome)
  };
};

const serverstateFromJson = (json) => {
  return ClearSplitMultiCollaboration.ServerState.create_ServerState(
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.appliedLog || []).map(x => actionFromJson(x))),
    _dafny.Seq.of(...(json.auditLog || []).map(x => requestrecordFromJson(x)))
  );
};

const serverstateToJson = (value) => {
  return {
    present: modelToJson(value.dtor_present),
    appliedLog: seqToArray(value.dtor_appliedLog).map(x => actionToJson(x)),
    auditLog: seqToArray(value.dtor_auditLog).map(x => requestrecordToJson(x))
  };
};

const clientstateFromJson = (json) => {
  return ClearSplitMultiCollaboration.ClientState.create_ClientState(
    new BigNumber(json.baseVersion),
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.pending || []).map(x => actionFromJson(x)))
  );
};

const clientstateToJson = (value) => {
  return {
    baseVersion: toNumber(value.dtor_baseVersion),
    present: modelToJson(value.dtor_present),
    pending: seqToArray(value.dtor_pending).map(x => actionToJson(x))
  };
};

const networkstatusFromJson = (json) => {
  switch (json) {
    case 'Online':
      return ClearSplitEffectStateMachine.NetworkStatus.create_Online();
    case 'Offline':
      return ClearSplitEffectStateMachine.NetworkStatus.create_Offline();
    default:
      throw new Error(`Unknown NetworkStatus: ${json}`);
  }
};

const networkstatusToJson = (value) => {
  if (value.is_Online) {
    return 'Online';
  } else if (value.is_Offline) {
    return 'Offline';
  }
  return 'Unknown';
};

const effectmodeFromJson = (json) => {
  switch (json.type) {
    case 'Idle':
      return ClearSplitEffectStateMachine.EffectMode.create_Idle();
    case 'Dispatching':
      return ClearSplitEffectStateMachine.EffectMode.create_Dispatching(
        new BigNumber(json.retries)
      );
    default:
      throw new Error(`Unknown EffectMode type: ${json.type}`);
  }
};

const effectmodeToJson = (value) => {
  if (value.is_Idle) {
    return { type: 'Idle' };
  } else if (value.is_Dispatching) {
    return {
      type: 'Dispatching',
      retries: toNumber(value.dtor_retries)
    };
  }
  return { type: 'Unknown' };
};

const effectstateFromJson = (json) => {
  return ClearSplitEffectStateMachine.EffectState.create_EffectState(
    networkstatusFromJson(json.network),
    effectmodeFromJson(json.mode),
    clientstateFromJson(json.client),
    new BigNumber(json.serverVersion)
  );
};

const effectstateToJson = (value) => {
  return {
    network: networkstatusToJson(value.dtor_network),
    mode: effectmodeToJson(value.dtor_mode),
    client: clientstateToJson(value.dtor_client),
    serverVersion: toNumber(value.dtor_serverVersion)
  };
};

const eventFromJson = (json) => {
  switch (json.type) {
    case 'UserAction':
      return ClearSplitEffectStateMachine.Event.create_UserAction(
        actionFromJson(json.action)
      );
    case 'DispatchAccepted':
      return ClearSplitEffectStateMachine.Event.create_DispatchAccepted(
        new BigNumber(json.newVersion),
        modelFromJson(json.newModel)
      );
    case 'DispatchConflict':
      return ClearSplitEffectStateMachine.Event.create_DispatchConflict(
        new BigNumber(json.freshVersion),
        modelFromJson(json.freshModel)
      );
    case 'DispatchRejected':
      return ClearSplitEffectStateMachine.Event.create_DispatchRejected(
        new BigNumber(json.freshVersion),
        modelFromJson(json.freshModel)
      );
    case 'NetworkError':
      return ClearSplitEffectStateMachine.Event.create_NetworkError();
    case 'NetworkRestored':
      return ClearSplitEffectStateMachine.Event.create_NetworkRestored();
    case 'ManualGoOffline':
      return ClearSplitEffectStateMachine.Event.create_ManualGoOffline();
    case 'ManualGoOnline':
      return ClearSplitEffectStateMachine.Event.create_ManualGoOnline();
    case 'Tick':
      return ClearSplitEffectStateMachine.Event.create_Tick();
    default:
      throw new Error(`Unknown Event type: ${json.type}`);
  }
};

const eventToJson = (value) => {
  if (value.is_UserAction) {
    return {
      type: 'UserAction',
      action: actionToJson(value.dtor_action)
    };
  } else if (value.is_DispatchAccepted) {
    return {
      type: 'DispatchAccepted',
      newVersion: toNumber(value.dtor_newVersion),
      newModel: modelToJson(value.dtor_newModel)
    };
  } else if (value.is_DispatchConflict) {
    return {
      type: 'DispatchConflict',
      freshVersion: toNumber(value.dtor_freshVersion),
      freshModel: modelToJson(value.dtor_freshModel)
    };
  } else if (value.is_DispatchRejected) {
    return {
      type: 'DispatchRejected',
      freshVersion: toNumber(value.dtor_freshVersion),
      freshModel: modelToJson(value.dtor_freshModel)
    };
  } else if (value.is_NetworkError) {
    return { type: 'NetworkError' };
  } else if (value.is_NetworkRestored) {
    return { type: 'NetworkRestored' };
  } else if (value.is_ManualGoOffline) {
    return { type: 'ManualGoOffline' };
  } else if (value.is_ManualGoOnline) {
    return { type: 'ManualGoOnline' };
  } else if (value.is_Tick) {
    return { type: 'Tick' };
  }
  return { type: 'Unknown' };
};

const commandFromJson = (json) => {
  switch (json.type) {
    case 'NoOp':
      return ClearSplitEffectStateMachine.Command.create_NoOp();
    case 'SendDispatch':
      return ClearSplitEffectStateMachine.Command.create_SendDispatch(
        new BigNumber(json.baseVersion),
        actionFromJson(json.action)
      );
    case 'FetchFreshState':
      return ClearSplitEffectStateMachine.Command.create_FetchFreshState();
    default:
      throw new Error(`Unknown Command type: ${json.type}`);
  }
};

const commandToJson = (value) => {
  if (value.is_NoOp) {
    return { type: 'NoOp' };
  } else if (value.is_SendDispatch) {
    return {
      type: 'SendDispatch',
      baseVersion: toNumber(value.dtor_baseVersion),
      action: actionToJson(value.dtor_action)
    };
  } else if (value.is_FetchFreshState) {
    return { type: 'FetchFreshState' };
  }
  return { type: 'Unknown' };
};

// ============================================================================
// API Wrapper
// ============================================================================

const App = {
  // Expense constructors
  Expense: (paidBy, amount, shares, shareKeys) => ClearSplit.Expense.create_Expense(_dafny.Seq.UnicodeFromString(paidBy), new BigNumber(amount), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(shares), _dafny.Seq.of(...(shareKeys || []).map(x => _dafny.Seq.UnicodeFromString(x)))),

  // Settlement constructors
  Settlement: (from, to, amount) => ClearSplit.Settlement.create_Settlement(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to), new BigNumber(amount)),

  // Result constructors
  Ok: (value) => ClearSplit.Result.create_Ok(value),
  Error: (error) => ClearSplit.Result.create_Error(error),

  // Err constructors
  NotMember: (p) => ClearSplit.Err.create_NotMember(_dafny.Seq.UnicodeFromString(p)),
  BadExpense: () => ClearSplit.Err.create_BadExpense(),
  BadSettlement: () => ClearSplit.Err.create_BadSettlement(),

  // Certificate constructors
  Certificate: (memberCount, expenseCount, settlementCount, conservationHolds) => ClearSplit.Certificate.create_Certificate(new BigNumber(memberCount), new BigNumber(expenseCount), new BigNumber(settlementCount), conservationHolds),

  // Action constructors
  AddExpense: (e) => ClearSplit.Action.create_AddExpense(e),
  AddSettlement: (s) => ClearSplit.Action.create_AddSettlement(s),

  // Model accessors
  GetMembers: (m) => Array.from(m.dtor_members.Elements).map(x => dafnyStringToJs(x)),
  GetMemberList: (m) => seqToArray(m.dtor_memberList).map(x => dafnyStringToJs(x)),
  GetExpenses: (m) => seqToArray(m.dtor_expenses).map(x => expenseToJson(x)),
  GetSettlements: (m) => seqToArray(m.dtor_settlements).map(x => settlementToJson(x)),

  // AppCore functions
  EffectInit: (version, model) => ClearSplitEffectAppCore.__default.EffectInit(new BigNumber(version), model),
  EffectStep: (es, event) => ClearSplitEffectAppCore.__default.EffectStep(es, event),
  EffectIsOnline: (es) => ClearSplitEffectAppCore.__default.EffectIsOnline(es),
  EffectIsIdle: (es) => ClearSplitEffectAppCore.__default.EffectIsIdle(es),
  EffectHasPending: (es) => ClearSplitEffectAppCore.__default.EffectHasPending(es),
  EffectPendingCount: (es) => toNumber(ClearSplitEffectAppCore.__default.EffectPendingCount(es)),
  EffectGetClient: (es) => ClearSplitEffectAppCore.__default.EffectGetClient(es),
  EffectGetServerVersion: (es) => toNumber(ClearSplitEffectAppCore.__default.EffectGetServerVersion(es)),
  EffectUserAction: (action) => ClearSplitEffectAppCore.__default.EffectUserAction(action),
  EffectDispatchAccepted: (version, model) => ClearSplitEffectAppCore.__default.EffectDispatchAccepted(new BigNumber(version), model),
  EffectDispatchConflict: (version, model) => ClearSplitEffectAppCore.__default.EffectDispatchConflict(new BigNumber(version), model),
  EffectDispatchRejected: (version, model) => ClearSplitEffectAppCore.__default.EffectDispatchRejected(new BigNumber(version), model),
  EffectNetworkError: () => ClearSplitEffectAppCore.__default.EffectNetworkError(),
  EffectNetworkRestored: () => ClearSplitEffectAppCore.__default.EffectNetworkRestored(),
  EffectManualGoOffline: () => ClearSplitEffectAppCore.__default.EffectManualGoOffline(),
  EffectManualGoOnline: () => ClearSplitEffectAppCore.__default.EffectManualGoOnline(),
  EffectTick: () => ClearSplitEffectAppCore.__default.EffectTick(),
  EffectIsNoOp: (cmd) => ClearSplitEffectAppCore.__default.EffectIsNoOp(cmd),
  EffectIsSendDispatch: (cmd) => ClearSplitEffectAppCore.__default.EffectIsSendDispatch(cmd),
  EffectGetBaseVersion: (cmd) => toNumber(ClearSplitEffectAppCore.__default.EffectGetBaseVersion(cmd)),
  EffectGetAction: (cmd) => ClearSplitEffectAppCore.__default.EffectGetAction(cmd),
  InitServerWithMembers: (memberList) => ClearSplitEffectAppCore.__default.InitServerWithMembers(_dafny.Seq.of(...(memberList || []).map(x => _dafny.Seq.UnicodeFromString(x)))),
  InitClientFromServer: (server) => ClearSplitEffectAppCore.__default.InitClientFromServer(server),
  InitClient: (version, model) => ClearSplitEffectAppCore.__default.InitClient(new BigNumber(version), model),
  MakeExpense: (paidBy, amount, shares, shareKeys) => ClearSplitEffectAppCore.__default.MakeExpense(_dafny.Seq.UnicodeFromString(paidBy), new BigNumber(amount), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(shares), _dafny.Seq.of(...(shareKeys || []).map(x => _dafny.Seq.UnicodeFromString(x)))),
  MakeSettlement: (from, to, amount) => ClearSplitEffectAppCore.__default.MakeSettlement(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to), new BigNumber(amount)),
  ClientLocalDispatch: (client, action) => ClearSplitEffectAppCore.__default.ClientLocalDispatch(client, action),
  HandleRealtimeUpdate: (client, serverVersion, serverModel) => ClearSplitEffectAppCore.__default.HandleRealtimeUpdate(client, new BigNumber(serverVersion), serverModel),
  ClientAcceptReply: (client, newVersion, newPresent) => ClearSplitEffectAppCore.__default.ClientAcceptReply(client, new BigNumber(newVersion), newPresent),
  ClientRejectReply: (client, freshVersion, freshModel) => ClearSplitEffectAppCore.__default.ClientRejectReply(client, new BigNumber(freshVersion), freshModel),
  ServerDispatch: (server, baseVersion, action) => ClearSplitEffectAppCore.__default.ServerDispatch(server, new BigNumber(baseVersion), action),
  ServerVersion: (server) => toNumber(ClearSplitEffectAppCore.__default.ServerVersion(server)),
  ClientModel: (client) => ClearSplitEffectAppCore.__default.ClientModel(client),
  ClientVersion: (client) => toNumber(ClearSplitEffectAppCore.__default.ClientVersion(client)),
  PendingCount: (client) => toNumber(ClearSplitEffectAppCore.__default.PendingCount(client)),
  IsAccepted: (reply) => ClearSplitEffectAppCore.__default.IsAccepted(reply),
  IsRejected: (reply) => ClearSplitEffectAppCore.__default.IsRejected(reply),
  Balances: (model) => ClearSplitEffectAppCore.__default.Balances(model),
  GetBalance: (model, p) => toNumber(ClearSplitEffectAppCore.__default.GetBalance(model, _dafny.Seq.UnicodeFromString(p))),
  Members: (model) => seqToArray(ClearSplitEffectAppCore.__default.Members(model)).map(x => dafnyStringToJs(x)),
  Expenses: (model) => seqToArray(ClearSplitEffectAppCore.__default.Expenses(model)).map(x => expenseToJson(x)),
  Settlements: (model) => seqToArray(ClearSplitEffectAppCore.__default.Settlements(model)).map(x => settlementToJson(x)),
  GetFirstPending: (client) => ClearSplitEffectAppCore.__default.GetFirstPending(client),
  HasPending: (client) => ClearSplitEffectAppCore.__default.HasPending(client),

  // Conversion functions
  expenseToJson: expenseToJson,
  expenseFromJson: expenseFromJson,
  settlementToJson: settlementToJson,
  settlementFromJson: settlementFromJson,
  modelToJson: modelToJson,
  modelFromJson: modelFromJson,
  resultToJson: resultToJson,
  resultFromJson: resultFromJson,
  errToJson: errToJson,
  errFromJson: errFromJson,
  actionToJson: actionToJson,
  actionFromJson: actionFromJson,
  certificateToJson: certificateToJson,
  certificateFromJson: certificateFromJson,
  actionToJson: actionToJson,
  actionFromJson: actionFromJson,
  rejectreasonToJson: rejectreasonToJson,
  rejectreasonFromJson: rejectreasonFromJson,
  replyToJson: replyToJson,
  replyFromJson: replyFromJson,
  requestoutcomeToJson: requestoutcomeToJson,
  requestoutcomeFromJson: requestoutcomeFromJson,
  requestrecordToJson: requestrecordToJson,
  requestrecordFromJson: requestrecordFromJson,
  serverstateToJson: serverstateToJson,
  serverstateFromJson: serverstateFromJson,
  clientstateToJson: clientstateToJson,
  clientstateFromJson: clientstateFromJson,
  networkstatusToJson: networkstatusToJson,
  networkstatusFromJson: networkstatusFromJson,
  effectmodeToJson: effectmodeToJson,
  effectmodeFromJson: effectmodeFromJson,
  effectstateToJson: effectstateToJson,
  effectstateFromJson: effectstateFromJson,
  eventToJson: eventToJson,
  eventFromJson: eventFromJson,
  commandToJson: commandToJson,
  commandFromJson: commandFromJson,
};

// Export internals for custom extensions
App._internal = { _dafny, ClearSplit, ClearSplitMultiCollaboration, ClearSplitEffectStateMachine, ClearSplitEffectAppCore };

export default App;
