// Generated by dafny2js
// Do not edit manually - regenerate from Dafny sources

import BigNumber from 'bignumber.js';

// Configure BigNumber as Dafny expects
BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });

// Import the generated code as raw text
import dafnyCode from './CanonReplay.cjs?raw';

// Set up the environment and evaluate the Dafny code
const require = (mod: string) => {
  if (mod === 'bignumber.js') return BigNumber;
  throw new Error(`Unknown module: ${mod}`);
};

// Create a function that evaluates the code with proper scope
const initDafny = new Function('require', `
  ${dafnyCode}
  return { _dafny, CanonDomain, Canon, CanonKernel, AppCore };
`);

const { _dafny, CanonDomain, Canon, CanonKernel, AppCore } = initDafny(require);

// ============================================================================
// Helpers
// ============================================================================

// deno-lint-ignore no-explicit-any
const seqToArray = (seq: any): any[] => {
  const arr = [];
  for (let i = 0; i < seq.length; i++) {
    arr.push(seq[i]);
  }
  return arr;
};

// deno-lint-ignore no-explicit-any
const toNumber = (bn: any): number => {
  if (bn && typeof bn.toNumber === 'function') {
    return bn.toNumber();
  }
  return bn;
};

// deno-lint-ignore no-explicit-any
const dafnyStringToJs = (seq: any): string => {
  if (typeof seq === 'string') return seq;
  if (seq.toVerbatimString) return seq.toVerbatimString(false);
  return Array.from(seq).join('');
};


// ============================================================================
// TypeScript Type Definitions (JSON representation)
// ============================================================================

export type Action =
  | { type: 'AddNode'; id: string; x: number; y: number }
  | { type: 'AddAlign'; sel: string[] }
  | { type: 'AddEvenSpace'; sel: string[] }
  | { type: 'AddEdge'; from: string; to: string }
  | { type: 'DeleteConstraint'; cid: number }
  | { type: 'DeleteEdge'; from: string; to: string }
  | { type: 'RemoveNode'; nodeId: string }
  | { type: 'MoveNode'; id: string; newX: number; newY: number };

export interface Node {
  id: string;
  x: number;
  y: number;
}

export type Axis = 'X' | 'Y';

export type Constraint =
  | { type: 'Align'; cid: number; targets: string[]; axis: Axis }
  | { type: 'EvenSpace'; cid: number; targets: string[]; axis: Axis };

export interface Edge {
  from: string;
  to: string;
}

export interface Model {
  nodes: Record<string, Node>;
  edges: Edge[];
  constraints: Constraint[];
  nextCid: number;
}

export interface History {
  past: Model[];
  present: Model;
  future: Model[];
}

// ============================================================================
// Dafny Runtime Types (actual Dafny runtime object shapes)
// ============================================================================

// Base Dafny runtime types
type DafnyInt = InstanceType<typeof BigNumber>;
interface DafnySeq<T = unknown> {
  readonly length: number;
  readonly [index: number]: T;
  toVerbatimString?(asLiteral: boolean): string;
  map<U>(fn: (x: T) => U): U[];
}
interface DafnySet<T = unknown> { readonly Elements: Iterable<T>; }
interface DafnyMap<K = unknown, V = unknown> {
  readonly Keys: DafnySet<K>;
  get(key: K): V;
  contains(key: K): boolean;
}

type DafnyAction = { readonly is_AddNode: true; readonly is_AddAlign: false; readonly is_AddEvenSpace: false; readonly is_AddEdge: false; readonly is_DeleteConstraint: false; readonly is_DeleteEdge: false; readonly is_RemoveNode: false; readonly is_MoveNode: false; readonly dtor_id: DafnySeq; readonly dtor_x: DafnyInt; readonly dtor_y: DafnyInt } | { readonly is_AddNode: false; readonly is_AddAlign: true; readonly is_AddEvenSpace: false; readonly is_AddEdge: false; readonly is_DeleteConstraint: false; readonly is_DeleteEdge: false; readonly is_RemoveNode: false; readonly is_MoveNode: false; readonly dtor_sel: DafnySeq<DafnySeq> } | { readonly is_AddNode: false; readonly is_AddAlign: false; readonly is_AddEvenSpace: true; readonly is_AddEdge: false; readonly is_DeleteConstraint: false; readonly is_DeleteEdge: false; readonly is_RemoveNode: false; readonly is_MoveNode: false; readonly dtor_sel: DafnySeq<DafnySeq> } | { readonly is_AddNode: false; readonly is_AddAlign: false; readonly is_AddEvenSpace: false; readonly is_AddEdge: true; readonly is_DeleteConstraint: false; readonly is_DeleteEdge: false; readonly is_RemoveNode: false; readonly is_MoveNode: false; readonly dtor_from: DafnySeq; readonly dtor_to: DafnySeq } | { readonly is_AddNode: false; readonly is_AddAlign: false; readonly is_AddEvenSpace: false; readonly is_AddEdge: false; readonly is_DeleteConstraint: true; readonly is_DeleteEdge: false; readonly is_RemoveNode: false; readonly is_MoveNode: false; readonly dtor_cid: DafnyInt } | { readonly is_AddNode: false; readonly is_AddAlign: false; readonly is_AddEvenSpace: false; readonly is_AddEdge: false; readonly is_DeleteConstraint: false; readonly is_DeleteEdge: true; readonly is_RemoveNode: false; readonly is_MoveNode: false; readonly dtor_from: DafnySeq; readonly dtor_to: DafnySeq } | { readonly is_AddNode: false; readonly is_AddAlign: false; readonly is_AddEvenSpace: false; readonly is_AddEdge: false; readonly is_DeleteConstraint: false; readonly is_DeleteEdge: false; readonly is_RemoveNode: true; readonly is_MoveNode: false; readonly dtor_nodeId: DafnySeq } | { readonly is_AddNode: false; readonly is_AddAlign: false; readonly is_AddEvenSpace: false; readonly is_AddEdge: false; readonly is_DeleteConstraint: false; readonly is_DeleteEdge: false; readonly is_RemoveNode: false; readonly is_MoveNode: true; readonly dtor_id: DafnySeq; readonly dtor_newX: DafnyInt; readonly dtor_newY: DafnyInt };

interface DafnyNode {
  readonly is_Node: true;
  readonly dtor_id: DafnySeq;
  readonly dtor_x: DafnyInt;
  readonly dtor_y: DafnyInt;
}

type DafnyAxis = { readonly is_X: true; readonly is_Y: false } | { readonly is_X: false; readonly is_Y: true };

type DafnyConstraint = { readonly is_Align: true; readonly is_EvenSpace: false; readonly dtor_cid: DafnyInt; readonly dtor_targets: DafnySeq<DafnySeq>; readonly dtor_axis: DafnyAxis } | { readonly is_Align: false; readonly is_EvenSpace: true; readonly dtor_cid: DafnyInt; readonly dtor_targets: DafnySeq<DafnySeq>; readonly dtor_axis: DafnyAxis };

interface DafnyEdge {
  readonly is_Edge: true;
  readonly dtor_from: DafnySeq;
  readonly dtor_to: DafnySeq;
}

interface DafnyModel {
  readonly is_Model: true;
  readonly dtor_nodes: DafnyMap<DafnySeq, DafnyNode>;
  readonly dtor_edges: DafnySeq<DafnyEdge>;
  readonly dtor_constraints: DafnySeq<DafnyConstraint>;
  readonly dtor_nextCid: DafnyInt;
}

interface DafnyHistory {
  readonly is_History: true;
  readonly dtor_past: DafnySeq<DafnyModel>;
  readonly dtor_present: DafnyModel;
  readonly dtor_future: DafnySeq<DafnyModel>;
}

// ============================================================================
// Datatype Conversions
// ============================================================================

// deno-lint-ignore no-explicit-any
const actionFromJson = (json: any): DafnyAction => {
  switch (json.type) {
    case 'AddNode': {
      return CanonDomain.Action.create_AddNode(
        _dafny.Seq.UnicodeFromString(json.id),
        new BigNumber(json.x),
        new BigNumber(json.y)
      );
    }
    case 'AddAlign': {
      return CanonDomain.Action.create_AddAlign(
        _dafny.Seq.of(...(json.sel || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))
      );
    }
    case 'AddEvenSpace': {
      return CanonDomain.Action.create_AddEvenSpace(
        _dafny.Seq.of(...(json.sel || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))
      );
    }
    case 'AddEdge': {
      return CanonDomain.Action.create_AddEdge(
        _dafny.Seq.UnicodeFromString(json.from),
        _dafny.Seq.UnicodeFromString(json.to)
      );
    }
    case 'DeleteConstraint': {
      return CanonDomain.Action.create_DeleteConstraint(
        new BigNumber(json.cid)
      );
    }
    case 'DeleteEdge': {
      return CanonDomain.Action.create_DeleteEdge(
        _dafny.Seq.UnicodeFromString(json.from),
        _dafny.Seq.UnicodeFromString(json.to)
      );
    }
    case 'RemoveNode': {
      return CanonDomain.Action.create_RemoveNode(
        _dafny.Seq.UnicodeFromString(json.nodeId)
      );
    }
    case 'MoveNode': {
      return CanonDomain.Action.create_MoveNode(
        _dafny.Seq.UnicodeFromString(json.id),
        new BigNumber(json.newX),
        new BigNumber(json.newY)
      );
    }
    default:
      throw new Error(`Unknown Action type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const actionToJson = (value: any): Action => {
  if (value.is_AddNode) {
    return {
      type: 'AddNode',
      id: dafnyStringToJs(value.dtor_id),
      x: toNumber(value.dtor_x),
      y: toNumber(value.dtor_y)
    };
  } else if (value.is_AddAlign) {
    return {
      type: 'AddAlign',
      sel: seqToArray(value.dtor_sel).map((x: any) => dafnyStringToJs(x))
    };
  } else if (value.is_AddEvenSpace) {
    return {
      type: 'AddEvenSpace',
      sel: seqToArray(value.dtor_sel).map((x: any) => dafnyStringToJs(x))
    };
  } else if (value.is_AddEdge) {
    return {
      type: 'AddEdge',
      from: dafnyStringToJs(value.dtor_from),
      to: dafnyStringToJs(value.dtor_to)
    };
  } else if (value.is_DeleteConstraint) {
    return {
      type: 'DeleteConstraint',
      cid: toNumber(value.dtor_cid)
    };
  } else if (value.is_DeleteEdge) {
    return {
      type: 'DeleteEdge',
      from: dafnyStringToJs(value.dtor_from),
      to: dafnyStringToJs(value.dtor_to)
    };
  } else if (value.is_RemoveNode) {
    return {
      type: 'RemoveNode',
      nodeId: dafnyStringToJs(value.dtor_nodeId)
    };
  } else if (value.is_MoveNode) {
    return {
      type: 'MoveNode',
      id: dafnyStringToJs(value.dtor_id),
      newX: toNumber(value.dtor_newX),
      newY: toNumber(value.dtor_newY)
    };
  }
  throw new Error('Unknown Action variant');
};

// deno-lint-ignore no-explicit-any
const nodeFromJson = (json: any): DafnyNode => {
  return Canon.Node.create_Node(
    _dafny.Seq.UnicodeFromString(json.id),
    new BigNumber(json.x),
    new BigNumber(json.y)
  );
};

// deno-lint-ignore no-explicit-any
const nodeToJson = (value: any): Node => {
  return {
    id: dafnyStringToJs(value.dtor_id),
    x: toNumber(value.dtor_x),
    y: toNumber(value.dtor_y)
  };
};

// deno-lint-ignore no-explicit-any
const axisFromJson = (json: any): DafnyAxis => {
  switch (json) {
    case 'X':
      return Canon.Axis.create_X();
    case 'Y':
      return Canon.Axis.create_Y();
    default:
      throw new Error(`Unknown Axis: ${json}`);
  }
};

// deno-lint-ignore no-explicit-any
const axisToJson = (value: any): Axis => {
  if (value.is_X) {
    return 'X';
  } else if (value.is_Y) {
    return 'Y';
  }
  throw new Error('Unknown Axis variant');
};

// deno-lint-ignore no-explicit-any
const constraintFromJson = (json: any): DafnyConstraint => {
  switch (json.type) {
    case 'Align': {
      return Canon.Constraint.create_Align(
        new BigNumber(json.cid),
        _dafny.Seq.of(...(json.targets || []).map((x: any) => _dafny.Seq.UnicodeFromString(x))),
        axisFromJson(json.axis)
      );
    }
    case 'EvenSpace': {
      return Canon.Constraint.create_EvenSpace(
        new BigNumber(json.cid),
        _dafny.Seq.of(...(json.targets || []).map((x: any) => _dafny.Seq.UnicodeFromString(x))),
        axisFromJson(json.axis)
      );
    }
    default:
      throw new Error(`Unknown Constraint type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const constraintToJson = (value: any): Constraint => {
  if (value.is_Align) {
    return {
      type: 'Align',
      cid: toNumber(value.dtor_cid),
      targets: seqToArray(value.dtor_targets).map((x: any) => dafnyStringToJs(x)),
      axis: axisToJson(value.dtor_axis)
    };
  } else if (value.is_EvenSpace) {
    return {
      type: 'EvenSpace',
      cid: toNumber(value.dtor_cid),
      targets: seqToArray(value.dtor_targets).map((x: any) => dafnyStringToJs(x)),
      axis: axisToJson(value.dtor_axis)
    };
  }
  throw new Error('Unknown Constraint variant');
};

// deno-lint-ignore no-explicit-any
const edgeFromJson = (json: any): DafnyEdge => {
  return Canon.Edge.create_Edge(
    _dafny.Seq.UnicodeFromString(json.from),
    _dafny.Seq.UnicodeFromString(json.to)
  );
};

// deno-lint-ignore no-explicit-any
const edgeToJson = (value: any): Edge => {
  return {
    from: dafnyStringToJs(value.dtor_from),
    to: dafnyStringToJs(value.dtor_to)
  };
};

// deno-lint-ignore no-explicit-any
const modelFromJson = (json: any): DafnyModel => {
  let __nodes = _dafny.Map.Empty;
  for (const [k, v] of (Object.entries(json.nodes || {}) as [string, any][])) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = nodeFromJson(v);
    __nodes = __nodes.update(key, val);
  }
  return Canon.Model.create_Model(
    __nodes,
    _dafny.Seq.of(...(json.edges || []).map((x: any) => edgeFromJson(x))),
    _dafny.Seq.of(...(json.constraints || []).map((x: any) => constraintFromJson(x))),
    new BigNumber(json.nextCid)
  );
};

// deno-lint-ignore no-explicit-any
const modelToJson = (value: any): Model => {
  const __nodesJson: Record<string, any> = {};
  if (value.dtor_nodes && value.dtor_nodes.Keys) {
    for (const k of value.dtor_nodes.Keys.Elements) {
      const v = value.dtor_nodes.get(k);
      __nodesJson[dafnyStringToJs(k)] = nodeToJson(v);
    }
  }
  return {
    nodes: __nodesJson,
    edges: seqToArray(value.dtor_edges).map((x: any) => edgeToJson(x)),
    constraints: seqToArray(value.dtor_constraints).map((x: any) => constraintToJson(x)),
    nextCid: toNumber(value.dtor_nextCid)
  };
};

// deno-lint-ignore no-explicit-any
const historyFromJson = (json: any): DafnyHistory => {
  return CanonKernel.History.create_History(
    _dafny.Seq.of(...(json.past || []).map((x: any) => modelFromJson(x))),
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.future || []).map((x: any) => modelFromJson(x)))
  );
};

// deno-lint-ignore no-explicit-any
const historyToJson = (value: any): History => {
  return {
    past: seqToArray(value.dtor_past).map((x: any) => modelToJson(x)),
    present: modelToJson(value.dtor_present),
    future: seqToArray(value.dtor_future).map((x: any) => modelToJson(x))
  };
};

// ============================================================================
// API Wrapper
// ============================================================================

interface AppInternal { _dafny: unknown; CanonDomain: unknown; Canon: unknown; CanonKernel: unknown; AppCore: unknown; }

const App = {
  // Action constructors
  AddNode: (id: string, x: number, y: number) => CanonDomain.Action.create_AddNode(_dafny.Seq.UnicodeFromString(id), new BigNumber(x), new BigNumber(y)),
  AddAlign: (sel: string[]) => CanonDomain.Action.create_AddAlign(_dafny.Seq.of(...(sel || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))),
  AddEvenSpace: (sel: string[]) => CanonDomain.Action.create_AddEvenSpace(_dafny.Seq.of(...(sel || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))),
  AddEdge: (from: string, to: string) => CanonDomain.Action.create_AddEdge(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to)),
  DeleteConstraint: (cid: number) => CanonDomain.Action.create_DeleteConstraint(new BigNumber(cid)),
  DeleteEdge: (from: string, to: string) => CanonDomain.Action.create_DeleteEdge(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to)),
  RemoveNode: (nodeId: string) => CanonDomain.Action.create_RemoveNode(_dafny.Seq.UnicodeFromString(nodeId)),
  MoveNode: (id: string, newX: number, newY: number) => CanonDomain.Action.create_MoveNode(_dafny.Seq.UnicodeFromString(id), new BigNumber(newX), new BigNumber(newY)),

  // AppCore functions
  Init: (): DafnyHistory => AppCore.__default.Init(),
  Dispatch: (h: DafnyHistory, a: DafnyAction): DafnyHistory => AppCore.__default.Dispatch(h, a),
  Undo: (h: DafnyHistory): DafnyHistory => AppCore.__default.Undo(h),
  Redo: (h: DafnyHistory): DafnyHistory => AppCore.__default.Redo(h),
  CanonHistory: (h: DafnyHistory): DafnyHistory => AppCore.__default.CanonHistory(h),
  Present: (h: DafnyHistory): DafnyModel => AppCore.__default.Present(h),
  CanUndo: (h: DafnyHistory): boolean => AppCore.__default.CanUndo(h),
  CanRedo: (h: DafnyHistory): boolean => AppCore.__default.CanRedo(h),
  Nodes: (h: DafnyHistory): DafnyMap<DafnySeq, DafnyNode> => AppCore.__default.Nodes(h),
  Edges: (h: DafnyHistory): Edge[] => seqToArray(AppCore.__default.Edges(h)).map(x => edgeToJson(x)),
  Constraints: (h: DafnyHistory): Constraint[] => seqToArray(AppCore.__default.Constraints(h)).map(x => constraintToJson(x)),

  // Conversion functions
  actionToJson,
  actionFromJson,
  nodeToJson,
  nodeFromJson,
  axisToJson,
  axisFromJson,
  constraintToJson,
  constraintFromJson,
  edgeToJson,
  edgeFromJson,
  modelToJson,
  modelFromJson,
  historyToJson,
  historyFromJson,

  // Internal modules for custom extensions
  _internal: { _dafny, CanonDomain, Canon, CanonKernel, AppCore } as AppInternal,
};

export default App;
