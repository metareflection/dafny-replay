// Generated by dafny2js
// Do not edit manually - regenerate from Dafny sources

import BigNumber from 'bignumber.js';

// Configure BigNumber as Dafny expects
BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });

// Import the generated code as raw text
import dafnyCode from './KanbanEffect.cjs?raw';

// Set up the environment and evaluate the Dafny code
const require = (mod) => {
  if (mod === 'bignumber.js') return BigNumber;
  throw new Error(`Unknown module: ${mod}`);
};

// Create a function that evaluates the code with proper scope
const initDafny = new Function('require', `
  ${dafnyCode}
  return { _dafny, KanbanDomain, KanbanMultiCollaboration, KanbanEffectStateMachine, KanbanEffectAppCore };
`);

const { _dafny, KanbanDomain, KanbanMultiCollaboration, KanbanEffectStateMachine, KanbanEffectAppCore } = initDafny(require);

// ============================================================================
// Helpers
// ============================================================================

const seqToArray = (seq) => {
  const arr = [];
  for (let i = 0; i < seq.length; i++) {
    arr.push(seq[i]);
  }
  return arr;
};

const toNumber = (bn) => {
  if (bn && typeof bn.toNumber === 'function') {
    return bn.toNumber();
  }
  return bn;
};

const dafnyStringToJs = (seq) => {
  if (typeof seq === 'string') return seq;
  if (seq.toVerbatimString) return seq.toVerbatimString(false);
  return Array.from(seq).join('');
};


// ============================================================================
// Datatype Conversions
// ============================================================================

const cardFromJson = (json) => {
  return KanbanDomain.Card.create_Card(
    _dafny.Seq.UnicodeFromString(json.title)
  );
};

const cardToJson = (value) => {
  return {
    title: dafnyStringToJs(value.dtor_title)
  };
};

const modelFromJson = (json) => {
  let __lanes = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.lanes || {})) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = _dafny.Seq.of(...(v || []).map(x => new BigNumber(x)));
    __lanes = __lanes.update(key, val);
  }
  let __wip = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.wip || {})) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = new BigNumber(v);
    __wip = __wip.update(key, val);
  }
  let __cards = _dafny.Map.Empty;
  for (const [k, v] of Object.entries(json.cards || {})) {
    const key = new BigNumber(k);
    const val = cardFromJson(v);
    __cards = __cards.update(key, val);
  }
  return KanbanDomain.Model.create_Model(
    _dafny.Seq.of(...(json.cols || []).map(x => _dafny.Seq.UnicodeFromString(x))),
    __lanes,
    __wip,
    __cards,
    new BigNumber(json.nextId)
  );
};

const modelToJson = (value) => {
  const __lanesJson = {};
  if (value.dtor_lanes && value.dtor_lanes.Keys) {
    for (const k of value.dtor_lanes.Keys.Elements) {
      const v = value.dtor_lanes.get(k);
      __lanesJson[dafnyStringToJs(k)] = seqToArray(v).map(x => toNumber(x));
    }
  }
  const __wipJson = {};
  if (value.dtor_wip && value.dtor_wip.Keys) {
    for (const k of value.dtor_wip.Keys.Elements) {
      const v = value.dtor_wip.get(k);
      __wipJson[dafnyStringToJs(k)] = toNumber(v);
    }
  }
  const __cardsJson = {};
  if (value.dtor_cards && value.dtor_cards.Keys) {
    for (const k of value.dtor_cards.Keys.Elements) {
      const v = value.dtor_cards.get(k);
      __cardsJson[toNumber(k)] = cardToJson(v);
    }
  }
  return {
    cols: seqToArray(value.dtor_cols).map(x => dafnyStringToJs(x)),
    lanes: __lanesJson,
    wip: __wipJson,
    cards: __cardsJson,
    nextId: toNumber(value.dtor_nextId)
  };
};

const errFromJson = (json) => {
  switch (json) {
    case 'MissingColumn':
      return KanbanDomain.Err.create_MissingColumn();
    case 'MissingCard':
      return KanbanDomain.Err.create_MissingCard();
    case 'WipExceeded':
      return KanbanDomain.Err.create_WipExceeded();
    case 'BadAnchor':
      return KanbanDomain.Err.create_BadAnchor();
    case 'Rejected':
      return KanbanDomain.Err.create_Rejected();
    default:
      throw new Error(`Unknown Err: ${json}`);
  }
};

const errToJson = (value) => {
  if (value.is_MissingColumn) {
    return 'MissingColumn';
  } else if (value.is_MissingCard) {
    return 'MissingCard';
  } else if (value.is_WipExceeded) {
    return 'WipExceeded';
  } else if (value.is_BadAnchor) {
    return 'BadAnchor';
  } else if (value.is_Rejected) {
    return 'Rejected';
  }
  return 'Unknown';
};

const optionFromJson = (json, T_fromJson) => {
  switch (json.type) {
    case 'None': {
      return KanbanDomain.Option.create_None();
    }
    case 'Some': {
      return KanbanDomain.Option.create_Some(
        T_fromJson(json.value)
      );
    }
    default:
      throw new Error(`Unknown Option type: ${json.type}`);
  }
};

const optionToJson = (value, T_toJson) => {
  if (value.is_None) {
    return { type: 'None' };
  } else if (value.is_Some) {
    return {
      type: 'Some',
      value: T_toJson(value.dtor_value)
    };
  }
  return { type: 'Unknown' };
};

const placeFromJson = (json) => {
  switch (json.type) {
    case 'AtEnd': {
      return KanbanDomain.Place.create_AtEnd();
    }
    case 'Before': {
      return KanbanDomain.Place.create_Before(
        new BigNumber(json.anchor)
      );
    }
    case 'After': {
      return KanbanDomain.Place.create_After(
        new BigNumber(json.anchor)
      );
    }
    default:
      throw new Error(`Unknown Place type: ${json.type}`);
  }
};

const placeToJson = (value) => {
  if (value.is_AtEnd) {
    return { type: 'AtEnd' };
  } else if (value.is_Before) {
    return {
      type: 'Before',
      anchor: toNumber(value.dtor_anchor)
    };
  } else if (value.is_After) {
    return {
      type: 'After',
      anchor: toNumber(value.dtor_anchor)
    };
  }
  return { type: 'Unknown' };
};

const actionFromJson = (json) => {
  switch (json.type) {
    case 'NoOp': {
      return KanbanDomain.Action.create_NoOp();
    }
    case 'AddColumn': {
      return KanbanDomain.Action.create_AddColumn(
        _dafny.Seq.UnicodeFromString(json.col),
        new BigNumber(json.limit)
      );
    }
    case 'SetWip': {
      return KanbanDomain.Action.create_SetWip(
        _dafny.Seq.UnicodeFromString(json.col),
        new BigNumber(json.limit)
      );
    }
    case 'AddCard': {
      return KanbanDomain.Action.create_AddCard(
        _dafny.Seq.UnicodeFromString(json.col),
        _dafny.Seq.UnicodeFromString(json.title)
      );
    }
    case 'MoveCard': {
      return KanbanDomain.Action.create_MoveCard(
        new BigNumber(json.id),
        _dafny.Seq.UnicodeFromString(json.toCol),
        placeFromJson(json.place)
      );
    }
    case 'EditTitle': {
      return KanbanDomain.Action.create_EditTitle(
        new BigNumber(json.id),
        _dafny.Seq.UnicodeFromString(json.title)
      );
    }
    default:
      throw new Error(`Unknown Action type: ${json.type}`);
  }
};

const actionToJson = (value) => {
  if (value.is_NoOp) {
    return { type: 'NoOp' };
  } else if (value.is_AddColumn) {
    return {
      type: 'AddColumn',
      col: dafnyStringToJs(value.dtor_col),
      limit: toNumber(value.dtor_limit)
    };
  } else if (value.is_SetWip) {
    return {
      type: 'SetWip',
      col: dafnyStringToJs(value.dtor_col),
      limit: toNumber(value.dtor_limit)
    };
  } else if (value.is_AddCard) {
    return {
      type: 'AddCard',
      col: dafnyStringToJs(value.dtor_col),
      title: dafnyStringToJs(value.dtor_title)
    };
  } else if (value.is_MoveCard) {
    return {
      type: 'MoveCard',
      id: toNumber(value.dtor_id),
      toCol: dafnyStringToJs(value.dtor_toCol),
      place: placeToJson(value.dtor_place)
    };
  } else if (value.is_EditTitle) {
    return {
      type: 'EditTitle',
      id: toNumber(value.dtor_id),
      title: dafnyStringToJs(value.dtor_title)
    };
  }
  return { type: 'Unknown' };
};

const resultFromJson = (json, T_fromJson, E_fromJson) => {
  switch (json.type) {
    case 'Ok': {
      return KanbanDomain.Result.create_Ok(
        T_fromJson(json.value)
      );
    }
    case 'Err': {
      return KanbanDomain.Result.create_Err(
        E_fromJson(json.error)
      );
    }
    default:
      throw new Error(`Unknown Result type: ${json.type}`);
  }
};

const resultToJson = (value, T_toJson, E_toJson) => {
  if (value.is_Ok) {
    return {
      type: 'Ok',
      value: T_toJson(value.dtor_value)
    };
  } else if (value.is_Err) {
    return {
      type: 'Err',
      error: E_toJson(value.dtor_error)
    };
  }
  return { type: 'Unknown' };
};

const rejectreasonFromJson = (json) => {
  return KanbanMultiCollaboration.RejectReason.create_DomainInvalid();
};

const rejectreasonToJson = (value) => {
  return {};
};

const replyFromJson = (json) => {
  switch (json.type) {
    case 'Accepted': {
      return KanbanMultiCollaboration.Reply.create_Accepted(
        new BigNumber(json.newVersion),
        modelFromJson(json.newPresent),
        actionFromJson(json.applied),
        json.noChange
      );
    }
    case 'Rejected': {
      return KanbanMultiCollaboration.Reply.create_Rejected(
        rejectreasonFromJson(json.reason),
        actionFromJson(json.rebased)
      );
    }
    default:
      throw new Error(`Unknown Reply type: ${json.type}`);
  }
};

const replyToJson = (value) => {
  if (value.is_Accepted) {
    return {
      type: 'Accepted',
      newVersion: toNumber(value.dtor_newVersion),
      newPresent: modelToJson(value.dtor_newPresent),
      applied: actionToJson(value.dtor_applied),
      noChange: value.dtor_noChange
    };
  } else if (value.is_Rejected) {
    return {
      type: 'Rejected',
      reason: rejectreasonToJson(value.dtor_reason),
      rebased: actionToJson(value.dtor_rebased)
    };
  }
  return { type: 'Unknown' };
};

const requestoutcomeFromJson = (json) => {
  switch (json.type) {
    case 'AuditAccepted': {
      return KanbanMultiCollaboration.RequestOutcome.create_AuditAccepted(
        actionFromJson(json.applied),
        json.noChange
      );
    }
    case 'AuditRejected': {
      return KanbanMultiCollaboration.RequestOutcome.create_AuditRejected(
        rejectreasonFromJson(json.reason),
        actionFromJson(json.rebased)
      );
    }
    default:
      throw new Error(`Unknown RequestOutcome type: ${json.type}`);
  }
};

const requestoutcomeToJson = (value) => {
  if (value.is_AuditAccepted) {
    return {
      type: 'AuditAccepted',
      applied: actionToJson(value.dtor_applied),
      noChange: value.dtor_noChange
    };
  } else if (value.is_AuditRejected) {
    return {
      type: 'AuditRejected',
      reason: rejectreasonToJson(value.dtor_reason),
      rebased: actionToJson(value.dtor_rebased)
    };
  }
  return { type: 'Unknown' };
};

const requestrecordFromJson = (json) => {
  return KanbanMultiCollaboration.RequestRecord.create_Req(
    new BigNumber(json.baseVersion),
    actionFromJson(json.orig),
    actionFromJson(json.rebased),
    actionFromJson(json.chosen),
    requestoutcomeFromJson(json.outcome)
  );
};

const requestrecordToJson = (value) => {
  return {
    baseVersion: toNumber(value.dtor_baseVersion),
    orig: actionToJson(value.dtor_orig),
    rebased: actionToJson(value.dtor_rebased),
    chosen: actionToJson(value.dtor_chosen),
    outcome: requestoutcomeToJson(value.dtor_outcome)
  };
};

const serverstateFromJson = (json) => {
  return KanbanMultiCollaboration.ServerState.create_ServerState(
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.appliedLog || []).map(x => actionFromJson(x))),
    _dafny.Seq.of(...(json.auditLog || []).map(x => requestrecordFromJson(x)))
  );
};

const serverstateToJson = (value) => {
  return {
    present: modelToJson(value.dtor_present),
    appliedLog: seqToArray(value.dtor_appliedLog).map(x => actionToJson(x)),
    auditLog: seqToArray(value.dtor_auditLog).map(x => requestrecordToJson(x))
  };
};

const clientstateFromJson = (json) => {
  return KanbanMultiCollaboration.ClientState.create_ClientState(
    new BigNumber(json.baseVersion),
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.pending || []).map(x => actionFromJson(x)))
  );
};

const clientstateToJson = (value) => {
  return {
    baseVersion: toNumber(value.dtor_baseVersion),
    present: modelToJson(value.dtor_present),
    pending: seqToArray(value.dtor_pending).map(x => actionToJson(x))
  };
};

const networkstatusFromJson = (json) => {
  switch (json) {
    case 'Online':
      return KanbanEffectStateMachine.NetworkStatus.create_Online();
    case 'Offline':
      return KanbanEffectStateMachine.NetworkStatus.create_Offline();
    default:
      throw new Error(`Unknown NetworkStatus: ${json}`);
  }
};

const networkstatusToJson = (value) => {
  if (value.is_Online) {
    return 'Online';
  } else if (value.is_Offline) {
    return 'Offline';
  }
  return 'Unknown';
};

const effectmodeFromJson = (json) => {
  switch (json.type) {
    case 'Idle': {
      return KanbanEffectStateMachine.EffectMode.create_Idle();
    }
    case 'Dispatching': {
      return KanbanEffectStateMachine.EffectMode.create_Dispatching(
        new BigNumber(json.retries)
      );
    }
    default:
      throw new Error(`Unknown EffectMode type: ${json.type}`);
  }
};

const effectmodeToJson = (value) => {
  if (value.is_Idle) {
    return { type: 'Idle' };
  } else if (value.is_Dispatching) {
    return {
      type: 'Dispatching',
      retries: toNumber(value.dtor_retries)
    };
  }
  return { type: 'Unknown' };
};

const effectstateFromJson = (json) => {
  return KanbanEffectStateMachine.EffectState.create_EffectState(
    networkstatusFromJson(json.network),
    effectmodeFromJson(json.mode),
    clientstateFromJson(json.client),
    new BigNumber(json.serverVersion)
  );
};

const effectstateToJson = (value) => {
  return {
    network: networkstatusToJson(value.dtor_network),
    mode: effectmodeToJson(value.dtor_mode),
    client: clientstateToJson(value.dtor_client),
    serverVersion: toNumber(value.dtor_serverVersion)
  };
};

const eventFromJson = (json) => {
  switch (json.type) {
    case 'UserAction': {
      return KanbanEffectStateMachine.Event.create_UserAction(
        actionFromJson(json.action)
      );
    }
    case 'DispatchAccepted': {
      return KanbanEffectStateMachine.Event.create_DispatchAccepted(
        new BigNumber(json.newVersion),
        modelFromJson(json.newModel)
      );
    }
    case 'DispatchConflict': {
      return KanbanEffectStateMachine.Event.create_DispatchConflict(
        new BigNumber(json.freshVersion),
        modelFromJson(json.freshModel)
      );
    }
    case 'DispatchRejected': {
      return KanbanEffectStateMachine.Event.create_DispatchRejected(
        new BigNumber(json.freshVersion),
        modelFromJson(json.freshModel)
      );
    }
    case 'NetworkError': {
      return KanbanEffectStateMachine.Event.create_NetworkError();
    }
    case 'NetworkRestored': {
      return KanbanEffectStateMachine.Event.create_NetworkRestored();
    }
    case 'ManualGoOffline': {
      return KanbanEffectStateMachine.Event.create_ManualGoOffline();
    }
    case 'ManualGoOnline': {
      return KanbanEffectStateMachine.Event.create_ManualGoOnline();
    }
    case 'Tick': {
      return KanbanEffectStateMachine.Event.create_Tick();
    }
    default:
      throw new Error(`Unknown Event type: ${json.type}`);
  }
};

const eventToJson = (value) => {
  if (value.is_UserAction) {
    return {
      type: 'UserAction',
      action: actionToJson(value.dtor_action)
    };
  } else if (value.is_DispatchAccepted) {
    return {
      type: 'DispatchAccepted',
      newVersion: toNumber(value.dtor_newVersion),
      newModel: modelToJson(value.dtor_newModel)
    };
  } else if (value.is_DispatchConflict) {
    return {
      type: 'DispatchConflict',
      freshVersion: toNumber(value.dtor_freshVersion),
      freshModel: modelToJson(value.dtor_freshModel)
    };
  } else if (value.is_DispatchRejected) {
    return {
      type: 'DispatchRejected',
      freshVersion: toNumber(value.dtor_freshVersion),
      freshModel: modelToJson(value.dtor_freshModel)
    };
  } else if (value.is_NetworkError) {
    return { type: 'NetworkError' };
  } else if (value.is_NetworkRestored) {
    return { type: 'NetworkRestored' };
  } else if (value.is_ManualGoOffline) {
    return { type: 'ManualGoOffline' };
  } else if (value.is_ManualGoOnline) {
    return { type: 'ManualGoOnline' };
  } else if (value.is_Tick) {
    return { type: 'Tick' };
  }
  return { type: 'Unknown' };
};

const commandFromJson = (json) => {
  switch (json.type) {
    case 'NoOp': {
      return KanbanEffectStateMachine.Command.create_NoOp();
    }
    case 'SendDispatch': {
      return KanbanEffectStateMachine.Command.create_SendDispatch(
        new BigNumber(json.baseVersion),
        actionFromJson(json.action)
      );
    }
    case 'FetchFreshState': {
      return KanbanEffectStateMachine.Command.create_FetchFreshState();
    }
    default:
      throw new Error(`Unknown Command type: ${json.type}`);
  }
};

const commandToJson = (value) => {
  if (value.is_NoOp) {
    return { type: 'NoOp' };
  } else if (value.is_SendDispatch) {
    return {
      type: 'SendDispatch',
      baseVersion: toNumber(value.dtor_baseVersion),
      action: actionToJson(value.dtor_action)
    };
  } else if (value.is_FetchFreshState) {
    return { type: 'FetchFreshState' };
  }
  return { type: 'Unknown' };
};

// ============================================================================
// API Wrapper
// ============================================================================

const App = {
  // Card constructors
  Card: (title) => KanbanDomain.Card.create_Card(_dafny.Seq.UnicodeFromString(title)),

  // Err constructors
  MissingColumn: () => KanbanDomain.Err.create_MissingColumn(),
  MissingCard: () => KanbanDomain.Err.create_MissingCard(),
  WipExceeded: () => KanbanDomain.Err.create_WipExceeded(),
  BadAnchor: () => KanbanDomain.Err.create_BadAnchor(),
  Rejected: () => KanbanDomain.Err.create_Rejected(),

  // Option constructors
  None: () => KanbanDomain.Option.create_None(),
  Some: (value) => KanbanDomain.Option.create_Some(value),

  // Place constructors
  AtEnd: () => KanbanDomain.Place.create_AtEnd(),
  Before: (anchor) => KanbanDomain.Place.create_Before(new BigNumber(anchor)),
  After: (anchor) => KanbanDomain.Place.create_After(new BigNumber(anchor)),

  // Result constructors
  Ok: (value) => KanbanDomain.Result.create_Ok(value),
  Err: (error) => KanbanDomain.Result.create_Err(error),

  // Action constructors
  NoOp: () => KanbanDomain.Action.create_NoOp(),
  AddColumn: (col, limit) => KanbanDomain.Action.create_AddColumn(_dafny.Seq.UnicodeFromString(col), new BigNumber(limit)),
  SetWip: (col, limit) => KanbanDomain.Action.create_SetWip(_dafny.Seq.UnicodeFromString(col), new BigNumber(limit)),
  AddCard: (col, title) => KanbanDomain.Action.create_AddCard(_dafny.Seq.UnicodeFromString(col), _dafny.Seq.UnicodeFromString(title)),
  MoveCard: (id, toCol, place) => KanbanDomain.Action.create_MoveCard(new BigNumber(id), _dafny.Seq.UnicodeFromString(toCol), place),
  EditTitle: (id, title) => KanbanDomain.Action.create_EditTitle(new BigNumber(id), _dafny.Seq.UnicodeFromString(title)),

  // Model accessors
  GetCols: (m) => seqToArray(m.dtor_cols).map(x => dafnyStringToJs(x)),
  GetLanes: (m, key) => {
    const dafnyKey = _dafny.Seq.UnicodeFromString(key);
    if (m.dtor_lanes.contains(dafnyKey)) {
      const val = m.dtor_lanes.get(dafnyKey);
      return seqToArray(val).map(x => toNumber(x));
    }
    return null;
  },
  GetWip: (m, key) => {
    const dafnyKey = _dafny.Seq.UnicodeFromString(key);
    if (m.dtor_wip.contains(dafnyKey)) {
      const val = m.dtor_wip.get(dafnyKey);
      return toNumber(val);
    }
    return null;
  },
  GetCards: (m, key) => {
    const dafnyKey = new BigNumber(key);
    if (m.dtor_cards.contains(dafnyKey)) {
      const val = m.dtor_cards.get(dafnyKey);
      return cardToJson(val);
    }
    return null;
  },
  GetNextId: (m) => toNumber(m.dtor_nextId),

  // AppCore functions
  EffectInit: (version, model) => KanbanEffectAppCore.__default.EffectInit(new BigNumber(version), model),
  EffectStep: (es, event) => KanbanEffectAppCore.__default.EffectStep(es, event),
  EffectIsOnline: (es) => KanbanEffectAppCore.__default.EffectIsOnline(es),
  EffectIsIdle: (es) => KanbanEffectAppCore.__default.EffectIsIdle(es),
  EffectHasPending: (es) => KanbanEffectAppCore.__default.EffectHasPending(es),
  EffectPendingCount: (es) => toNumber(KanbanEffectAppCore.__default.EffectPendingCount(es)),
  EffectGetClient: (es) => KanbanEffectAppCore.__default.EffectGetClient(es),
  EffectGetServerVersion: (es) => toNumber(KanbanEffectAppCore.__default.EffectGetServerVersion(es)),
  EffectUserAction: (action) => KanbanEffectAppCore.__default.EffectUserAction(action),
  EffectDispatchAccepted: (version, model) => KanbanEffectAppCore.__default.EffectDispatchAccepted(new BigNumber(version), model),
  EffectDispatchConflict: (version, model) => KanbanEffectAppCore.__default.EffectDispatchConflict(new BigNumber(version), model),
  EffectDispatchRejected: (version, model) => KanbanEffectAppCore.__default.EffectDispatchRejected(new BigNumber(version), model),
  EffectNetworkError: () => KanbanEffectAppCore.__default.EffectNetworkError(),
  EffectNetworkRestored: () => KanbanEffectAppCore.__default.EffectNetworkRestored(),
  EffectManualGoOffline: () => KanbanEffectAppCore.__default.EffectManualGoOffline(),
  EffectManualGoOnline: () => KanbanEffectAppCore.__default.EffectManualGoOnline(),
  EffectTick: () => KanbanEffectAppCore.__default.EffectTick(),
  EffectIsNoOp: (cmd) => KanbanEffectAppCore.__default.EffectIsNoOp(cmd),
  EffectIsSendDispatch: (cmd) => KanbanEffectAppCore.__default.EffectIsSendDispatch(cmd),
  EffectGetBaseVersion: (cmd) => toNumber(KanbanEffectAppCore.__default.EffectGetBaseVersion(cmd)),
  EffectGetAction: (cmd) => KanbanEffectAppCore.__default.EffectGetAction(cmd),
  MakeClientState: (baseVersion, present, pending) => KanbanEffectAppCore.__default.MakeClientState(new BigNumber(baseVersion), present, _dafny.Seq.of(...(pending || []).map(x => actionFromJson(x)))),
  Init: () => KanbanEffectAppCore.__default.Init(),
  InitServerWithModel: (initModel) => KanbanEffectAppCore.__default.InitServerWithModel(initModel),
  InitClientFromServer: (server) => KanbanEffectAppCore.__default.InitClientFromServer(server),
  ClientLocalDispatch: (client, action) => KanbanEffectAppCore.__default.ClientLocalDispatch(client, action),
  HandleRealtimeUpdate: (client, serverVersion, serverModel) => KanbanEffectAppCore.__default.HandleRealtimeUpdate(client, new BigNumber(serverVersion), serverModel),
  ClientAcceptReply: (client, newVersion, newPresent) => KanbanEffectAppCore.__default.ClientAcceptReply(client, new BigNumber(newVersion), newPresent),
  Sync: (server) => KanbanEffectAppCore.__default.Sync(server),
  ServerVersion: (server) => toNumber(KanbanEffectAppCore.__default.ServerVersion(server)),
  ServerModel: (server) => KanbanEffectAppCore.__default.ServerModel(server),
  AuditLength: (server) => toNumber(KanbanEffectAppCore.__default.AuditLength(server)),
  PendingCount: (client) => toNumber(KanbanEffectAppCore.__default.PendingCount(client)),
  ClientModel: (client) => KanbanEffectAppCore.__default.ClientModel(client),
  ClientVersion: (client) => toNumber(KanbanEffectAppCore.__default.ClientVersion(client)),
  IsAccepted: (reply) => KanbanEffectAppCore.__default.IsAccepted(reply),
  IsRejected: (reply) => KanbanEffectAppCore.__default.IsRejected(reply),

  // Conversion functions
  cardToJson: cardToJson,
  cardFromJson: cardFromJson,
  modelToJson: modelToJson,
  modelFromJson: modelFromJson,
  errToJson: errToJson,
  errFromJson: errFromJson,
  optionToJson: optionToJson,
  optionFromJson: optionFromJson,
  placeToJson: placeToJson,
  placeFromJson: placeFromJson,
  actionToJson: actionToJson,
  actionFromJson: actionFromJson,
  resultToJson: resultToJson,
  resultFromJson: resultFromJson,
  rejectreasonToJson: rejectreasonToJson,
  rejectreasonFromJson: rejectreasonFromJson,
  replyToJson: replyToJson,
  replyFromJson: replyFromJson,
  requestoutcomeToJson: requestoutcomeToJson,
  requestoutcomeFromJson: requestoutcomeFromJson,
  requestrecordToJson: requestrecordToJson,
  requestrecordFromJson: requestrecordFromJson,
  serverstateToJson: serverstateToJson,
  serverstateFromJson: serverstateFromJson,
  clientstateToJson: clientstateToJson,
  clientstateFromJson: clientstateFromJson,
  networkstatusToJson: networkstatusToJson,
  networkstatusFromJson: networkstatusFromJson,
  effectmodeToJson: effectmodeToJson,
  effectmodeFromJson: effectmodeFromJson,
  effectstateToJson: effectstateToJson,
  effectstateFromJson: effectstateFromJson,
  eventToJson: eventToJson,
  eventFromJson: eventFromJson,
  commandToJson: commandToJson,
  commandFromJson: commandFromJson,
};

// Export internals for custom extensions
App._internal = { _dafny, KanbanDomain, KanbanMultiCollaboration, KanbanEffectStateMachine, KanbanEffectAppCore };

export default App;
