// Generated by dafny2js
// Do not edit manually - regenerate from Dafny sources

import BigNumber from 'bignumber.js';

// Configure BigNumber as Dafny expects
BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });

// Import the generated code as raw text
import dafnyCode from './KanbanEffect.cjs?raw';

// Set up the environment and evaluate the Dafny code
const require = (mod: string) => {
  if (mod === 'bignumber.js') return BigNumber;
  throw new Error(`Unknown module: ${mod}`);
};

// Create a function that evaluates the code with proper scope
const initDafny = new Function('require', `
  ${dafnyCode}
  return { _dafny, KanbanDomain, KanbanMultiCollaboration, KanbanEffectStateMachine, KanbanEffectAppCore };
`);

const { _dafny, KanbanDomain, KanbanMultiCollaboration, KanbanEffectStateMachine, KanbanEffectAppCore } = initDafny(require);

// ============================================================================
// Helpers
// ============================================================================

// deno-lint-ignore no-explicit-any
const seqToArray = (seq: any): any[] => {
  const arr = [];
  for (let i = 0; i < seq.length; i++) {
    arr.push(seq[i]);
  }
  return arr;
};

// deno-lint-ignore no-explicit-any
const toNumber = (bn: any): number => {
  if (bn && typeof bn.toNumber === 'function') {
    return bn.toNumber();
  }
  return bn;
};

// deno-lint-ignore no-explicit-any
const dafnyStringToJs = (seq: any): string => {
  if (typeof seq === 'string') return seq;
  if (seq.toVerbatimString) return seq.toVerbatimString(false);
  return Array.from(seq).join('');
};


// ============================================================================
// TypeScript Type Definitions (JSON representation)
// ============================================================================

export interface Card {
  title: string;
}

export interface Model {
  cols: string[];
  lanes: Record<string, number[]>;
  wip: Record<string, number>;
  cards: Record<string, Card>;
  nextId: number;
}

export type Err = 'MissingColumn' | 'MissingCard' | 'WipExceeded' | 'BadAnchor' | 'Rejected';

export type Option<T> =
  | { type: 'None' }
  | { type: 'Some'; value: unknown };

export type Place =
  | { type: 'AtEnd' }
  | { type: 'Before'; anchor: number }
  | { type: 'After'; anchor: number };

export type Action =
  | { type: 'NoOp' }
  | { type: 'AddColumn'; col: string; limit: number }
  | { type: 'SetWip'; col: string; limit: number }
  | { type: 'AddCard'; col: string; title: string }
  | { type: 'MoveCard'; id: number; toCol: string; place: Place }
  | { type: 'EditTitle'; id: number; title: string };

export type Result<T, E> =
  | { type: 'Ok'; value: unknown }
  | { type: 'Err'; error: unknown };

export interface RejectReason {
}

export type Reply =
  | { type: 'Accepted'; newVersion: number; newPresent: Model; applied: Action; noChange: boolean }
  | { type: 'Rejected'; reason: RejectReason; rebased: Action };

export type RequestOutcome =
  | { type: 'AuditAccepted'; applied: Action; noChange: boolean }
  | { type: 'AuditRejected'; reason: RejectReason; rebased: Action };

export interface RequestRecord {
  baseVersion: number;
  orig: Action;
  rebased: Action;
  chosen: Action;
  outcome: RequestOutcome;
}

export interface ServerState {
  present: Model;
  appliedLog: Action[];
  auditLog: RequestRecord[];
}

export interface ClientState {
  baseVersion: number;
  present: Model;
  pending: Action[];
}

export type NetworkStatus = 'Online' | 'Offline';

export type EffectMode =
  | { type: 'Idle' }
  | { type: 'Dispatching'; retries: number };

export interface EffectState {
  network: NetworkStatus;
  mode: EffectMode;
  client: ClientState;
  serverVersion: number;
}

export type Event =
  | { type: 'UserAction'; action: Action }
  | { type: 'DispatchAccepted'; newVersion: number; newModel: Model }
  | { type: 'DispatchConflict'; freshVersion: number; freshModel: Model }
  | { type: 'DispatchRejected'; freshVersion: number; freshModel: Model }
  | { type: 'NetworkError' }
  | { type: 'NetworkRestored' }
  | { type: 'ManualGoOffline' }
  | { type: 'ManualGoOnline' }
  | { type: 'Tick' };

export type Command =
  | { type: 'NoOp' }
  | { type: 'SendDispatch'; baseVersion: number; action: Action }
  | { type: 'FetchFreshState' };

// ============================================================================
// Dafny Runtime Types (actual Dafny runtime object shapes)
// ============================================================================

// Base Dafny runtime types
type DafnyInt = InstanceType<typeof BigNumber>;
interface DafnySeq<T = unknown> {
  readonly length: number;
  readonly [index: number]: T;
  toVerbatimString?(asLiteral: boolean): string;
  map<U>(fn: (x: T) => U): U[];
}
interface DafnySet<T = unknown> { readonly Elements: Iterable<T>; }
interface DafnyMap<K = unknown, V = unknown> {
  readonly Keys: DafnySet<K>;
  get(key: K): V;
  contains(key: K): boolean;
}
type DafnyTuple2<T0, T1> = readonly [T0, T1];
type DafnyTuple3<T0, T1, T2> = readonly [T0, T1, T2];

interface DafnyCard {
  readonly is_Card: true;
  readonly dtor_title: DafnySeq;
}

interface DafnyModel {
  readonly is_Model: true;
  readonly dtor_cols: DafnySeq<DafnySeq>;
  readonly dtor_lanes: DafnyMap<DafnySeq, DafnySeq<DafnyInt>>;
  readonly dtor_wip: DafnyMap<DafnySeq, DafnyInt>;
  readonly dtor_cards: DafnyMap<DafnyInt, DafnyCard>;
  readonly dtor_nextId: DafnyInt;
}

type DafnyErr = { readonly is_MissingColumn: true; readonly is_MissingCard: false; readonly is_WipExceeded: false; readonly is_BadAnchor: false; readonly is_Rejected: false } | { readonly is_MissingColumn: false; readonly is_MissingCard: true; readonly is_WipExceeded: false; readonly is_BadAnchor: false; readonly is_Rejected: false } | { readonly is_MissingColumn: false; readonly is_MissingCard: false; readonly is_WipExceeded: true; readonly is_BadAnchor: false; readonly is_Rejected: false } | { readonly is_MissingColumn: false; readonly is_MissingCard: false; readonly is_WipExceeded: false; readonly is_BadAnchor: true; readonly is_Rejected: false } | { readonly is_MissingColumn: false; readonly is_MissingCard: false; readonly is_WipExceeded: false; readonly is_BadAnchor: false; readonly is_Rejected: true };

type DafnyOption<T> = { readonly is_None: true; readonly is_Some: false } | { readonly is_None: false; readonly is_Some: true; readonly dtor_value: T };

type DafnyPlace = { readonly is_AtEnd: true; readonly is_Before: false; readonly is_After: false } | { readonly is_AtEnd: false; readonly is_Before: true; readonly is_After: false; readonly dtor_anchor: DafnyInt } | { readonly is_AtEnd: false; readonly is_Before: false; readonly is_After: true; readonly dtor_anchor: DafnyInt };

type DafnyAction = { readonly is_NoOp: true; readonly is_AddColumn: false; readonly is_SetWip: false; readonly is_AddCard: false; readonly is_MoveCard: false; readonly is_EditTitle: false } | { readonly is_NoOp: false; readonly is_AddColumn: true; readonly is_SetWip: false; readonly is_AddCard: false; readonly is_MoveCard: false; readonly is_EditTitle: false; readonly dtor_col: DafnySeq; readonly dtor_limit: DafnyInt } | { readonly is_NoOp: false; readonly is_AddColumn: false; readonly is_SetWip: true; readonly is_AddCard: false; readonly is_MoveCard: false; readonly is_EditTitle: false; readonly dtor_col: DafnySeq; readonly dtor_limit: DafnyInt } | { readonly is_NoOp: false; readonly is_AddColumn: false; readonly is_SetWip: false; readonly is_AddCard: true; readonly is_MoveCard: false; readonly is_EditTitle: false; readonly dtor_col: DafnySeq; readonly dtor_title: DafnySeq } | { readonly is_NoOp: false; readonly is_AddColumn: false; readonly is_SetWip: false; readonly is_AddCard: false; readonly is_MoveCard: true; readonly is_EditTitle: false; readonly dtor_id: DafnyInt; readonly dtor_toCol: DafnySeq; readonly dtor_place: DafnyPlace } | { readonly is_NoOp: false; readonly is_AddColumn: false; readonly is_SetWip: false; readonly is_AddCard: false; readonly is_MoveCard: false; readonly is_EditTitle: true; readonly dtor_id: DafnyInt; readonly dtor_title: DafnySeq };

type DafnyResult<T, E> = { readonly is_Ok: true; readonly is_Err: false; readonly dtor_value: T } | { readonly is_Ok: false; readonly is_Err: true; readonly dtor_error: E };

interface DafnyRejectReason {
  readonly is_DomainInvalid: true;
}

type DafnyReply = { readonly is_Accepted: true; readonly is_Rejected: false; readonly dtor_newVersion: DafnyInt; readonly dtor_newPresent: DafnyModel; readonly dtor_applied: DafnyAction; readonly dtor_noChange: boolean } | { readonly is_Accepted: false; readonly is_Rejected: true; readonly dtor_reason: DafnyRejectReason; readonly dtor_rebased: DafnyAction };

type DafnyRequestOutcome = { readonly is_AuditAccepted: true; readonly is_AuditRejected: false; readonly dtor_applied: DafnyAction; readonly dtor_noChange: boolean } | { readonly is_AuditAccepted: false; readonly is_AuditRejected: true; readonly dtor_reason: DafnyRejectReason; readonly dtor_rebased: DafnyAction };

interface DafnyRequestRecord {
  readonly is_Req: true;
  readonly dtor_baseVersion: DafnyInt;
  readonly dtor_orig: DafnyAction;
  readonly dtor_rebased: DafnyAction;
  readonly dtor_chosen: DafnyAction;
  readonly dtor_outcome: DafnyRequestOutcome;
}

interface DafnyServerState {
  readonly is_ServerState: true;
  readonly dtor_present: DafnyModel;
  readonly dtor_appliedLog: DafnySeq<DafnyAction>;
  readonly dtor_auditLog: DafnySeq<DafnyRequestRecord>;
}

interface DafnyClientState {
  readonly is_ClientState: true;
  readonly dtor_baseVersion: DafnyInt;
  readonly dtor_present: DafnyModel;
  readonly dtor_pending: DafnySeq<DafnyAction>;
}

type DafnyNetworkStatus = { readonly is_Online: true; readonly is_Offline: false } | { readonly is_Online: false; readonly is_Offline: true };

type DafnyEffectMode = { readonly is_Idle: true; readonly is_Dispatching: false } | { readonly is_Idle: false; readonly is_Dispatching: true; readonly dtor_retries: DafnyInt };

interface DafnyEffectState {
  readonly is_EffectState: true;
  readonly dtor_network: DafnyNetworkStatus;
  readonly dtor_mode: DafnyEffectMode;
  readonly dtor_client: DafnyClientState;
  readonly dtor_serverVersion: DafnyInt;
}

type DafnyEvent = { readonly is_UserAction: true; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false; readonly dtor_action: DafnyAction } | { readonly is_UserAction: false; readonly is_DispatchAccepted: true; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false; readonly dtor_newVersion: DafnyInt; readonly dtor_newModel: DafnyModel } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: true; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false; readonly dtor_freshVersion: DafnyInt; readonly dtor_freshModel: DafnyModel } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: true; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false; readonly dtor_freshVersion: DafnyInt; readonly dtor_freshModel: DafnyModel } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: true; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: true; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: true; readonly is_ManualGoOnline: false; readonly is_Tick: false } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: true; readonly is_Tick: false } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: true };

type DafnyCommand = { readonly is_NoOp: true; readonly is_SendDispatch: false; readonly is_FetchFreshState: false } | { readonly is_NoOp: false; readonly is_SendDispatch: true; readonly is_FetchFreshState: false; readonly dtor_baseVersion: DafnyInt; readonly dtor_action: DafnyAction } | { readonly is_NoOp: false; readonly is_SendDispatch: false; readonly is_FetchFreshState: true };

// ============================================================================
// Datatype Conversions
// ============================================================================

// deno-lint-ignore no-explicit-any
const cardFromJson = (json: any): DafnyCard => {
  return KanbanDomain.Card.create_Card(
    _dafny.Seq.UnicodeFromString(json.title)
  );
};

// deno-lint-ignore no-explicit-any
const cardToJson = (value: any): Card => {
  return {
    title: dafnyStringToJs(value.dtor_title)
  };
};

// deno-lint-ignore no-explicit-any
const modelFromJson = (json: any): DafnyModel => {
  let __lanes = _dafny.Map.Empty;
  for (const [k, v] of (Object.entries(json.lanes || {}) as [string, any][])) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = _dafny.Seq.of(...(v || []).map((x: any) => new BigNumber(x)));
    __lanes = __lanes.update(key, val);
  }
  let __wip = _dafny.Map.Empty;
  for (const [k, v] of (Object.entries(json.wip || {}) as [string, any][])) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = new BigNumber(v);
    __wip = __wip.update(key, val);
  }
  let __cards = _dafny.Map.Empty;
  for (const [k, v] of (Object.entries(json.cards || {}) as [string, any][])) {
    const key = new BigNumber(k);
    const val = cardFromJson(v);
    __cards = __cards.update(key, val);
  }
  return KanbanDomain.Model.create_Model(
    _dafny.Seq.of(...(json.cols || []).map((x: any) => _dafny.Seq.UnicodeFromString(x))),
    __lanes,
    __wip,
    __cards,
    new BigNumber(json.nextId)
  );
};

// deno-lint-ignore no-explicit-any
const modelToJson = (value: any): Model => {
  const __lanesJson: Record<string, any> = {};
  if (value.dtor_lanes && value.dtor_lanes.Keys) {
    for (const k of value.dtor_lanes.Keys.Elements) {
      const v = value.dtor_lanes.get(k);
      __lanesJson[dafnyStringToJs(k)] = seqToArray(v).map((x: any) => toNumber(x));
    }
  }
  const __wipJson: Record<string, any> = {};
  if (value.dtor_wip && value.dtor_wip.Keys) {
    for (const k of value.dtor_wip.Keys.Elements) {
      const v = value.dtor_wip.get(k);
      __wipJson[dafnyStringToJs(k)] = toNumber(v);
    }
  }
  const __cardsJson: Record<string, any> = {};
  if (value.dtor_cards && value.dtor_cards.Keys) {
    for (const k of value.dtor_cards.Keys.Elements) {
      const v = value.dtor_cards.get(k);
      __cardsJson[toNumber(k)] = cardToJson(v);
    }
  }
  return {
    cols: seqToArray(value.dtor_cols).map((x: any) => dafnyStringToJs(x)),
    lanes: __lanesJson,
    wip: __wipJson,
    cards: __cardsJson,
    nextId: toNumber(value.dtor_nextId)
  };
};

// deno-lint-ignore no-explicit-any
const errFromJson = (json: any): DafnyErr => {
  switch (json) {
    case 'MissingColumn':
      return KanbanDomain.Err.create_MissingColumn();
    case 'MissingCard':
      return KanbanDomain.Err.create_MissingCard();
    case 'WipExceeded':
      return KanbanDomain.Err.create_WipExceeded();
    case 'BadAnchor':
      return KanbanDomain.Err.create_BadAnchor();
    case 'Rejected':
      return KanbanDomain.Err.create_Rejected();
    default:
      throw new Error(`Unknown Err: ${json}`);
  }
};

// deno-lint-ignore no-explicit-any
const errToJson = (value: any): Err => {
  if (value.is_MissingColumn) {
    return 'MissingColumn';
  } else if (value.is_MissingCard) {
    return 'MissingCard';
  } else if (value.is_WipExceeded) {
    return 'WipExceeded';
  } else if (value.is_BadAnchor) {
    return 'BadAnchor';
  } else if (value.is_Rejected) {
    return 'Rejected';
  }
  throw new Error('Unknown Err variant');
};

// deno-lint-ignore no-explicit-any
const optionFromJson = <T>(json: any, T_fromJson: (x: any) => T): DafnyOption<T> => {
  switch (json.type) {
    case 'None': {
      return KanbanDomain.Option.create_None();
    }
    case 'Some': {
      return KanbanDomain.Option.create_Some(
        T_fromJson(json.value)
      );
    }
    default:
      throw new Error(`Unknown Option type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const optionToJson = <T>(value: any, T_toJson: (x: any) => any): Option<T> => {
  if (value.is_None) {
    return { type: 'None' };
  } else if (value.is_Some) {
    return {
      type: 'Some',
      value: T_toJson(value.dtor_value)
    };
  }
  throw new Error('Unknown Option variant');
};

// deno-lint-ignore no-explicit-any
const placeFromJson = (json: any): DafnyPlace => {
  switch (json.type) {
    case 'AtEnd': {
      return KanbanDomain.Place.create_AtEnd();
    }
    case 'Before': {
      return KanbanDomain.Place.create_Before(
        new BigNumber(json.anchor)
      );
    }
    case 'After': {
      return KanbanDomain.Place.create_After(
        new BigNumber(json.anchor)
      );
    }
    default:
      throw new Error(`Unknown Place type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const placeToJson = (value: any): Place => {
  if (value.is_AtEnd) {
    return { type: 'AtEnd' };
  } else if (value.is_Before) {
    return {
      type: 'Before',
      anchor: toNumber(value.dtor_anchor)
    };
  } else if (value.is_After) {
    return {
      type: 'After',
      anchor: toNumber(value.dtor_anchor)
    };
  }
  throw new Error('Unknown Place variant');
};

// deno-lint-ignore no-explicit-any
const actionFromJson = (json: any): DafnyAction => {
  switch (json.type) {
    case 'NoOp': {
      return KanbanDomain.Action.create_NoOp();
    }
    case 'AddColumn': {
      return KanbanDomain.Action.create_AddColumn(
        _dafny.Seq.UnicodeFromString(json.col),
        new BigNumber(json.limit)
      );
    }
    case 'SetWip': {
      return KanbanDomain.Action.create_SetWip(
        _dafny.Seq.UnicodeFromString(json.col),
        new BigNumber(json.limit)
      );
    }
    case 'AddCard': {
      return KanbanDomain.Action.create_AddCard(
        _dafny.Seq.UnicodeFromString(json.col),
        _dafny.Seq.UnicodeFromString(json.title)
      );
    }
    case 'MoveCard': {
      return KanbanDomain.Action.create_MoveCard(
        new BigNumber(json.id),
        _dafny.Seq.UnicodeFromString(json.toCol),
        placeFromJson(json.place)
      );
    }
    case 'EditTitle': {
      return KanbanDomain.Action.create_EditTitle(
        new BigNumber(json.id),
        _dafny.Seq.UnicodeFromString(json.title)
      );
    }
    default:
      throw new Error(`Unknown Action type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const actionToJson = (value: any): Action => {
  if (value.is_NoOp) {
    return { type: 'NoOp' };
  } else if (value.is_AddColumn) {
    return {
      type: 'AddColumn',
      col: dafnyStringToJs(value.dtor_col),
      limit: toNumber(value.dtor_limit)
    };
  } else if (value.is_SetWip) {
    return {
      type: 'SetWip',
      col: dafnyStringToJs(value.dtor_col),
      limit: toNumber(value.dtor_limit)
    };
  } else if (value.is_AddCard) {
    return {
      type: 'AddCard',
      col: dafnyStringToJs(value.dtor_col),
      title: dafnyStringToJs(value.dtor_title)
    };
  } else if (value.is_MoveCard) {
    return {
      type: 'MoveCard',
      id: toNumber(value.dtor_id),
      toCol: dafnyStringToJs(value.dtor_toCol),
      place: placeToJson(value.dtor_place)
    };
  } else if (value.is_EditTitle) {
    return {
      type: 'EditTitle',
      id: toNumber(value.dtor_id),
      title: dafnyStringToJs(value.dtor_title)
    };
  }
  throw new Error('Unknown Action variant');
};

// deno-lint-ignore no-explicit-any
const resultFromJson = <T, E>(json: any, T_fromJson: (x: any) => T, E_fromJson: (x: any) => E): DafnyResult<T, E> => {
  switch (json.type) {
    case 'Ok': {
      return KanbanDomain.Result.create_Ok(
        T_fromJson(json.value)
      );
    }
    case 'Err': {
      return KanbanDomain.Result.create_Err(
        E_fromJson(json.error)
      );
    }
    default:
      throw new Error(`Unknown Result type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const resultToJson = <T, E>(value: any, T_toJson: (x: any) => any, E_toJson: (x: any) => any): Result<T, E> => {
  if (value.is_Ok) {
    return {
      type: 'Ok',
      value: T_toJson(value.dtor_value)
    };
  } else if (value.is_Err) {
    return {
      type: 'Err',
      error: E_toJson(value.dtor_error)
    };
  }
  throw new Error('Unknown Result variant');
};

// deno-lint-ignore no-explicit-any
const rejectreasonFromJson = (json: any): DafnyRejectReason => {
  return KanbanMultiCollaboration.RejectReason.create_DomainInvalid();
};

// deno-lint-ignore no-explicit-any
const rejectreasonToJson = (value: any): RejectReason => {
  return {};
};

// deno-lint-ignore no-explicit-any
const replyFromJson = (json: any): DafnyReply => {
  switch (json.type) {
    case 'Accepted': {
      return KanbanMultiCollaboration.Reply.create_Accepted(
        new BigNumber(json.newVersion),
        modelFromJson(json.newPresent),
        actionFromJson(json.applied),
        json.noChange
      );
    }
    case 'Rejected': {
      return KanbanMultiCollaboration.Reply.create_Rejected(
        rejectreasonFromJson(json.reason),
        actionFromJson(json.rebased)
      );
    }
    default:
      throw new Error(`Unknown Reply type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const replyToJson = (value: any): Reply => {
  if (value.is_Accepted) {
    return {
      type: 'Accepted',
      newVersion: toNumber(value.dtor_newVersion),
      newPresent: modelToJson(value.dtor_newPresent),
      applied: actionToJson(value.dtor_applied),
      noChange: value.dtor_noChange
    };
  } else if (value.is_Rejected) {
    return {
      type: 'Rejected',
      reason: rejectreasonToJson(value.dtor_reason),
      rebased: actionToJson(value.dtor_rebased)
    };
  }
  throw new Error('Unknown Reply variant');
};

// deno-lint-ignore no-explicit-any
const requestoutcomeFromJson = (json: any): DafnyRequestOutcome => {
  switch (json.type) {
    case 'AuditAccepted': {
      return KanbanMultiCollaboration.RequestOutcome.create_AuditAccepted(
        actionFromJson(json.applied),
        json.noChange
      );
    }
    case 'AuditRejected': {
      return KanbanMultiCollaboration.RequestOutcome.create_AuditRejected(
        rejectreasonFromJson(json.reason),
        actionFromJson(json.rebased)
      );
    }
    default:
      throw new Error(`Unknown RequestOutcome type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const requestoutcomeToJson = (value: any): RequestOutcome => {
  if (value.is_AuditAccepted) {
    return {
      type: 'AuditAccepted',
      applied: actionToJson(value.dtor_applied),
      noChange: value.dtor_noChange
    };
  } else if (value.is_AuditRejected) {
    return {
      type: 'AuditRejected',
      reason: rejectreasonToJson(value.dtor_reason),
      rebased: actionToJson(value.dtor_rebased)
    };
  }
  throw new Error('Unknown RequestOutcome variant');
};

// deno-lint-ignore no-explicit-any
const requestrecordFromJson = (json: any): DafnyRequestRecord => {
  return KanbanMultiCollaboration.RequestRecord.create_Req(
    new BigNumber(json.baseVersion),
    actionFromJson(json.orig),
    actionFromJson(json.rebased),
    actionFromJson(json.chosen),
    requestoutcomeFromJson(json.outcome)
  );
};

// deno-lint-ignore no-explicit-any
const requestrecordToJson = (value: any): RequestRecord => {
  return {
    baseVersion: toNumber(value.dtor_baseVersion),
    orig: actionToJson(value.dtor_orig),
    rebased: actionToJson(value.dtor_rebased),
    chosen: actionToJson(value.dtor_chosen),
    outcome: requestoutcomeToJson(value.dtor_outcome)
  };
};

// deno-lint-ignore no-explicit-any
const serverstateFromJson = (json: any): DafnyServerState => {
  return KanbanMultiCollaboration.ServerState.create_ServerState(
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.appliedLog || []).map((x: any) => actionFromJson(x))),
    _dafny.Seq.of(...(json.auditLog || []).map((x: any) => requestrecordFromJson(x)))
  );
};

// deno-lint-ignore no-explicit-any
const serverstateToJson = (value: any): ServerState => {
  return {
    present: modelToJson(value.dtor_present),
    appliedLog: seqToArray(value.dtor_appliedLog).map((x: any) => actionToJson(x)),
    auditLog: seqToArray(value.dtor_auditLog).map((x: any) => requestrecordToJson(x))
  };
};

// deno-lint-ignore no-explicit-any
const clientstateFromJson = (json: any): DafnyClientState => {
  return KanbanMultiCollaboration.ClientState.create_ClientState(
    new BigNumber(json.baseVersion),
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.pending || []).map((x: any) => actionFromJson(x)))
  );
};

// deno-lint-ignore no-explicit-any
const clientstateToJson = (value: any): ClientState => {
  return {
    baseVersion: toNumber(value.dtor_baseVersion),
    present: modelToJson(value.dtor_present),
    pending: seqToArray(value.dtor_pending).map((x: any) => actionToJson(x))
  };
};

// deno-lint-ignore no-explicit-any
const networkstatusFromJson = (json: any): DafnyNetworkStatus => {
  switch (json) {
    case 'Online':
      return KanbanEffectStateMachine.NetworkStatus.create_Online();
    case 'Offline':
      return KanbanEffectStateMachine.NetworkStatus.create_Offline();
    default:
      throw new Error(`Unknown NetworkStatus: ${json}`);
  }
};

// deno-lint-ignore no-explicit-any
const networkstatusToJson = (value: any): NetworkStatus => {
  if (value.is_Online) {
    return 'Online';
  } else if (value.is_Offline) {
    return 'Offline';
  }
  throw new Error('Unknown NetworkStatus variant');
};

// deno-lint-ignore no-explicit-any
const effectmodeFromJson = (json: any): DafnyEffectMode => {
  switch (json.type) {
    case 'Idle': {
      return KanbanEffectStateMachine.EffectMode.create_Idle();
    }
    case 'Dispatching': {
      return KanbanEffectStateMachine.EffectMode.create_Dispatching(
        new BigNumber(json.retries)
      );
    }
    default:
      throw new Error(`Unknown EffectMode type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const effectmodeToJson = (value: any): EffectMode => {
  if (value.is_Idle) {
    return { type: 'Idle' };
  } else if (value.is_Dispatching) {
    return {
      type: 'Dispatching',
      retries: toNumber(value.dtor_retries)
    };
  }
  throw new Error('Unknown EffectMode variant');
};

// deno-lint-ignore no-explicit-any
const effectstateFromJson = (json: any): DafnyEffectState => {
  return KanbanEffectStateMachine.EffectState.create_EffectState(
    networkstatusFromJson(json.network),
    effectmodeFromJson(json.mode),
    clientstateFromJson(json.client),
    new BigNumber(json.serverVersion)
  );
};

// deno-lint-ignore no-explicit-any
const effectstateToJson = (value: any): EffectState => {
  return {
    network: networkstatusToJson(value.dtor_network),
    mode: effectmodeToJson(value.dtor_mode),
    client: clientstateToJson(value.dtor_client),
    serverVersion: toNumber(value.dtor_serverVersion)
  };
};

// deno-lint-ignore no-explicit-any
const eventFromJson = (json: any): DafnyEvent => {
  switch (json.type) {
    case 'UserAction': {
      return KanbanEffectStateMachine.Event.create_UserAction(
        actionFromJson(json.action)
      );
    }
    case 'DispatchAccepted': {
      return KanbanEffectStateMachine.Event.create_DispatchAccepted(
        new BigNumber(json.newVersion),
        modelFromJson(json.newModel)
      );
    }
    case 'DispatchConflict': {
      return KanbanEffectStateMachine.Event.create_DispatchConflict(
        new BigNumber(json.freshVersion),
        modelFromJson(json.freshModel)
      );
    }
    case 'DispatchRejected': {
      return KanbanEffectStateMachine.Event.create_DispatchRejected(
        new BigNumber(json.freshVersion),
        modelFromJson(json.freshModel)
      );
    }
    case 'NetworkError': {
      return KanbanEffectStateMachine.Event.create_NetworkError();
    }
    case 'NetworkRestored': {
      return KanbanEffectStateMachine.Event.create_NetworkRestored();
    }
    case 'ManualGoOffline': {
      return KanbanEffectStateMachine.Event.create_ManualGoOffline();
    }
    case 'ManualGoOnline': {
      return KanbanEffectStateMachine.Event.create_ManualGoOnline();
    }
    case 'Tick': {
      return KanbanEffectStateMachine.Event.create_Tick();
    }
    default:
      throw new Error(`Unknown Event type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const eventToJson = (value: any): Event => {
  if (value.is_UserAction) {
    return {
      type: 'UserAction',
      action: actionToJson(value.dtor_action)
    };
  } else if (value.is_DispatchAccepted) {
    return {
      type: 'DispatchAccepted',
      newVersion: toNumber(value.dtor_newVersion),
      newModel: modelToJson(value.dtor_newModel)
    };
  } else if (value.is_DispatchConflict) {
    return {
      type: 'DispatchConflict',
      freshVersion: toNumber(value.dtor_freshVersion),
      freshModel: modelToJson(value.dtor_freshModel)
    };
  } else if (value.is_DispatchRejected) {
    return {
      type: 'DispatchRejected',
      freshVersion: toNumber(value.dtor_freshVersion),
      freshModel: modelToJson(value.dtor_freshModel)
    };
  } else if (value.is_NetworkError) {
    return { type: 'NetworkError' };
  } else if (value.is_NetworkRestored) {
    return { type: 'NetworkRestored' };
  } else if (value.is_ManualGoOffline) {
    return { type: 'ManualGoOffline' };
  } else if (value.is_ManualGoOnline) {
    return { type: 'ManualGoOnline' };
  } else if (value.is_Tick) {
    return { type: 'Tick' };
  }
  throw new Error('Unknown Event variant');
};

// deno-lint-ignore no-explicit-any
const commandFromJson = (json: any): DafnyCommand => {
  switch (json.type) {
    case 'NoOp': {
      return KanbanEffectStateMachine.Command.create_NoOp();
    }
    case 'SendDispatch': {
      return KanbanEffectStateMachine.Command.create_SendDispatch(
        new BigNumber(json.baseVersion),
        actionFromJson(json.action)
      );
    }
    case 'FetchFreshState': {
      return KanbanEffectStateMachine.Command.create_FetchFreshState();
    }
    default:
      throw new Error(`Unknown Command type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const commandToJson = (value: any): Command => {
  if (value.is_NoOp) {
    return { type: 'NoOp' };
  } else if (value.is_SendDispatch) {
    return {
      type: 'SendDispatch',
      baseVersion: toNumber(value.dtor_baseVersion),
      action: actionToJson(value.dtor_action)
    };
  } else if (value.is_FetchFreshState) {
    return { type: 'FetchFreshState' };
  }
  throw new Error('Unknown Command variant');
};

// ============================================================================
// API Wrapper
// ============================================================================

interface AppInternal { _dafny: unknown; KanbanDomain: unknown; KanbanMultiCollaboration: unknown; KanbanEffectStateMachine: unknown; KanbanEffectAppCore: unknown; }

const App = {
  // Card constructors
  Card: (title: string) => KanbanDomain.Card.create_Card(_dafny.Seq.UnicodeFromString(title)),

  // Err constructors
  MissingColumn: () => KanbanDomain.Err.create_MissingColumn(),
  MissingCard: () => KanbanDomain.Err.create_MissingCard(),
  WipExceeded: () => KanbanDomain.Err.create_WipExceeded(),
  BadAnchor: () => KanbanDomain.Err.create_BadAnchor(),
  Rejected: () => KanbanDomain.Err.create_Rejected(),

  // Option constructors
  None: () => KanbanDomain.Option.create_None(),
  Some: (value: unknown) => KanbanDomain.Option.create_Some(value),

  // Place constructors
  AtEnd: () => KanbanDomain.Place.create_AtEnd(),
  Before: (anchor: number) => KanbanDomain.Place.create_Before(new BigNumber(anchor)),
  After: (anchor: number) => KanbanDomain.Place.create_After(new BigNumber(anchor)),

  // Result constructors
  Ok: (value: unknown) => KanbanDomain.Result.create_Ok(value),
  Err: (error: unknown) => KanbanDomain.Result.create_Err(error),

  // Action constructors
  NoOp: () => KanbanDomain.Action.create_NoOp(),
  AddColumn: (col: string, limit: number) => KanbanDomain.Action.create_AddColumn(_dafny.Seq.UnicodeFromString(col), new BigNumber(limit)),
  SetWip: (col: string, limit: number) => KanbanDomain.Action.create_SetWip(_dafny.Seq.UnicodeFromString(col), new BigNumber(limit)),
  AddCard: (col: string, title: string) => KanbanDomain.Action.create_AddCard(_dafny.Seq.UnicodeFromString(col), _dafny.Seq.UnicodeFromString(title)),
  MoveCard: (id: number, toCol: string, place: DafnyPlace) => KanbanDomain.Action.create_MoveCard(new BigNumber(id), _dafny.Seq.UnicodeFromString(toCol), place),
  EditTitle: (id: number, title: string) => KanbanDomain.Action.create_EditTitle(new BigNumber(id), _dafny.Seq.UnicodeFromString(title)),

  // Model accessors
  GetCols: (m: DafnyModel) => seqToArray(m.dtor_cols).map((x: any) => dafnyStringToJs(x)),
  GetLanes: (m: DafnyModel, key: string) => {
    const dafnyKey = _dafny.Seq.UnicodeFromString(key);
    if (m.dtor_lanes.contains(dafnyKey)) {
      const val = m.dtor_lanes.get(dafnyKey);
      return seqToArray(val).map((x: any) => toNumber(x));
    }
    return null;
  },
  GetWip: (m: DafnyModel, key: string) => {
    const dafnyKey = _dafny.Seq.UnicodeFromString(key);
    if (m.dtor_wip.contains(dafnyKey)) {
      const val = m.dtor_wip.get(dafnyKey);
      return toNumber(val);
    }
    return null;
  },
  GetCards: (m: DafnyModel, key: number) => {
    const dafnyKey = new BigNumber(key);
    if (m.dtor_cards.contains(dafnyKey)) {
      const val = m.dtor_cards.get(dafnyKey);
      return cardToJson(val);
    }
    return null;
  },
  GetNextId: (m: DafnyModel) => toNumber(m.dtor_nextId),

  // AppCore functions
  EffectInit: (version: number, model: DafnyModel) => KanbanEffectAppCore.__default.EffectInit(new BigNumber(version), model),
  EffectStep: (es: DafnyEffectState, event: DafnyEvent) => KanbanEffectAppCore.__default.EffectStep(es, event),
  EffectIsOnline: (es: DafnyEffectState) => KanbanEffectAppCore.__default.EffectIsOnline(es),
  EffectIsIdle: (es: DafnyEffectState) => KanbanEffectAppCore.__default.EffectIsIdle(es),
  EffectHasPending: (es: DafnyEffectState) => KanbanEffectAppCore.__default.EffectHasPending(es),
  EffectPendingCount: (es: DafnyEffectState) => toNumber(KanbanEffectAppCore.__default.EffectPendingCount(es)),
  EffectGetClient: (es: DafnyEffectState) => KanbanEffectAppCore.__default.EffectGetClient(es),
  EffectGetServerVersion: (es: DafnyEffectState) => toNumber(KanbanEffectAppCore.__default.EffectGetServerVersion(es)),
  EffectUserAction: (action: DafnyAction) => KanbanEffectAppCore.__default.EffectUserAction(action),
  EffectDispatchAccepted: (version: number, model: DafnyModel) => KanbanEffectAppCore.__default.EffectDispatchAccepted(new BigNumber(version), model),
  EffectDispatchConflict: (version: number, model: DafnyModel) => KanbanEffectAppCore.__default.EffectDispatchConflict(new BigNumber(version), model),
  EffectDispatchRejected: (version: number, model: DafnyModel) => KanbanEffectAppCore.__default.EffectDispatchRejected(new BigNumber(version), model),
  EffectNetworkError: () => KanbanEffectAppCore.__default.EffectNetworkError(),
  EffectNetworkRestored: () => KanbanEffectAppCore.__default.EffectNetworkRestored(),
  EffectManualGoOffline: () => KanbanEffectAppCore.__default.EffectManualGoOffline(),
  EffectManualGoOnline: () => KanbanEffectAppCore.__default.EffectManualGoOnline(),
  EffectTick: () => KanbanEffectAppCore.__default.EffectTick(),
  EffectIsNoOp: (cmd: DafnyCommand) => KanbanEffectAppCore.__default.EffectIsNoOp(cmd),
  EffectIsSendDispatch: (cmd: DafnyCommand) => KanbanEffectAppCore.__default.EffectIsSendDispatch(cmd),
  EffectGetBaseVersion: (cmd: DafnyCommand) => toNumber(KanbanEffectAppCore.__default.EffectGetBaseVersion(cmd)),
  EffectGetAction: (cmd: DafnyCommand) => KanbanEffectAppCore.__default.EffectGetAction(cmd),
  MakeClientState: (baseVersion: number, present: DafnyModel, pending: Action[]) => KanbanEffectAppCore.__default.MakeClientState(new BigNumber(baseVersion), present, _dafny.Seq.of(...(pending || []).map((x: any) => actionFromJson(x)))),
  Init: () => KanbanEffectAppCore.__default.Init(),
  InitServerWithModel: (initModel: DafnyModel) => KanbanEffectAppCore.__default.InitServerWithModel(initModel),
  InitClientFromServer: (server: DafnyServerState) => KanbanEffectAppCore.__default.InitClientFromServer(server),
  ClientLocalDispatch: (client: DafnyClientState, action: DafnyAction) => KanbanEffectAppCore.__default.ClientLocalDispatch(client, action),
  HandleRealtimeUpdate: (client: DafnyClientState, serverVersion: number, serverModel: DafnyModel) => KanbanEffectAppCore.__default.HandleRealtimeUpdate(client, new BigNumber(serverVersion), serverModel),
  ClientAcceptReply: (client: DafnyClientState, newVersion: number, newPresent: DafnyModel) => KanbanEffectAppCore.__default.ClientAcceptReply(client, new BigNumber(newVersion), newPresent),
  Sync: (server: DafnyServerState) => KanbanEffectAppCore.__default.Sync(server),
  ServerVersion: (server: DafnyServerState) => toNumber(KanbanEffectAppCore.__default.ServerVersion(server)),
  ServerModel: (server: DafnyServerState) => KanbanEffectAppCore.__default.ServerModel(server),
  AuditLength: (server: DafnyServerState) => toNumber(KanbanEffectAppCore.__default.AuditLength(server)),
  PendingCount: (client: DafnyClientState) => toNumber(KanbanEffectAppCore.__default.PendingCount(client)),
  ClientModel: (client: DafnyClientState) => KanbanEffectAppCore.__default.ClientModel(client),
  ClientVersion: (client: DafnyClientState) => toNumber(KanbanEffectAppCore.__default.ClientVersion(client)),
  IsAccepted: (reply: DafnyReply) => KanbanEffectAppCore.__default.IsAccepted(reply),
  IsRejected: (reply: DafnyReply) => KanbanEffectAppCore.__default.IsRejected(reply),

  // Conversion functions
  cardToJson,
  cardFromJson,
  modelToJson,
  modelFromJson,
  errToJson,
  errFromJson,
  optionToJson,
  optionFromJson,
  placeToJson,
  placeFromJson,
  actionToJson,
  actionFromJson,
  resultToJson,
  resultFromJson,
  rejectreasonToJson,
  rejectreasonFromJson,
  replyToJson,
  replyFromJson,
  requestoutcomeToJson,
  requestoutcomeFromJson,
  requestrecordToJson,
  requestrecordFromJson,
  serverstateToJson,
  serverstateFromJson,
  clientstateToJson,
  clientstateFromJson,
  networkstatusToJson,
  networkstatusFromJson,
  effectmodeToJson,
  effectmodeFromJson,
  effectstateToJson,
  effectstateFromJson,
  eventToJson,
  eventFromJson,
  commandToJson,
  commandFromJson,

  // Internal modules for custom extensions
  _internal: { _dafny, KanbanDomain, KanbanMultiCollaboration, KanbanEffectStateMachine, KanbanEffectAppCore } as AppInternal,
};

export default App;
