// Generated by dafny2js
// Do not edit manually - regenerate from Dafny sources

import BigNumber from 'bignumber.js';

// Configure BigNumber as Dafny expects
BigNumber.config({ MODULO_MODE: BigNumber.EUCLID });

// Import the generated code as raw text
import dafnyCode from './ClearSplitEffect.cjs?raw';

// Set up the environment and evaluate the Dafny code
const require = (mod: string) => {
  if (mod === 'bignumber.js') return BigNumber;
  throw new Error(`Unknown module: ${mod}`);
};

// Create a function that evaluates the code with proper scope
const initDafny = new Function('require', `
  ${dafnyCode}
  return { _dafny, ClearSplit, ClearSplitMultiCollaboration, ClearSplitEffectStateMachine, ClearSplitCrossGroup, ClearSplitEffectAppCore };
`);

const { _dafny, ClearSplit, ClearSplitMultiCollaboration, ClearSplitEffectStateMachine, ClearSplitCrossGroup, ClearSplitEffectAppCore } = initDafny(require);

// ============================================================================
// Helpers
// ============================================================================

// deno-lint-ignore no-explicit-any
const seqToArray = (seq: any): any[] => {
  const arr = [];
  for (let i = 0; i < seq.length; i++) {
    arr.push(seq[i]);
  }
  return arr;
};

// deno-lint-ignore no-explicit-any
const toNumber = (bn: any): number => {
  if (bn && typeof bn.toNumber === 'function') {
    return bn.toNumber();
  }
  return bn;
};

// deno-lint-ignore no-explicit-any
const dafnyStringToJs = (seq: any): string => {
  if (typeof seq === 'string') return seq;
  if (seq.toVerbatimString) return seq.toVerbatimString(false);
  return Array.from(seq).join('');
};


// ============================================================================
// TypeScript Type Definitions (JSON representation)
// ============================================================================

export interface Expense {
  paidBy: string;
  amount: number;
  shares: Record<string, number>;
  shareKeys: string[];
}

export interface Settlement {
  from: string;
  to: string;
  amount: number;
}

export interface Model {
  members: string[];
  memberList: string[];
  expenses: Expense[];
  settlements: Settlement[];
}

export type Result<T, E> =
  | { type: 'Ok'; value: unknown }
  | { type: 'Error'; error: unknown };

export type Err =
  | { type: 'NotMember'; p: string }
  | { type: 'BadExpense' }
  | { type: 'BadSettlement' };

export type Action =
  | { type: 'AddExpense'; e: Expense }
  | { type: 'AddSettlement'; s: Settlement };

export interface Certificate {
  memberCount: number;
  expenseCount: number;
  settlementCount: number;
  conservationHolds: boolean;
}

export interface RejectReason {
}

export type Reply =
  | { type: 'Accepted'; newVersion: number; newPresent: Model; applied: Action; noChange: boolean }
  | { type: 'Rejected'; reason: RejectReason; rebased: Action };

export type RequestOutcome =
  | { type: 'AuditAccepted'; applied: Action; noChange: boolean }
  | { type: 'AuditRejected'; reason: RejectReason; rebased: Action };

export interface RequestRecord {
  baseVersion: number;
  orig: Action;
  rebased: Action;
  chosen: Action;
  outcome: RequestOutcome;
}

export interface ServerState {
  present: Model;
  appliedLog: Action[];
  auditLog: RequestRecord[];
}

export interface ClientState {
  baseVersion: number;
  present: Model;
  pending: Action[];
}

export type NetworkStatus = 'Online' | 'Offline';

export type EffectMode =
  | { type: 'Idle' }
  | { type: 'Dispatching'; retries: number };

export interface EffectState {
  network: NetworkStatus;
  mode: EffectMode;
  client: ClientState;
  serverVersion: number;
}

export type Event =
  | { type: 'UserAction'; action: Action }
  | { type: 'DispatchAccepted'; newVersion: number; newModel: Model }
  | { type: 'DispatchConflict'; freshVersion: number; freshModel: Model }
  | { type: 'DispatchRejected'; freshVersion: number; freshModel: Model }
  | { type: 'NetworkError' }
  | { type: 'NetworkRestored' }
  | { type: 'ManualGoOffline' }
  | { type: 'ManualGoOnline' }
  | { type: 'Tick' };

export type Command =
  | { type: 'NoOp' }
  | { type: 'SendDispatch'; baseVersion: number; action: Action }
  | { type: 'FetchFreshState' };

export interface GroupEntry {
  groupName: string;
  displayName: string;
  model: Model;
}

export interface GroupBalance {
  groupName: string;
  balance: number;
}

export interface CrossGroupSummary {
  totalOwed: number;
  totalOwes: number;
  netBalance: number;
  groups: GroupBalance[];
}

// ============================================================================
// Dafny Runtime Types (actual Dafny runtime object shapes)
// ============================================================================

// Base Dafny runtime types
type DafnyInt = InstanceType<typeof BigNumber>;
interface DafnySeq<T = unknown> {
  readonly length: number;
  readonly [index: number]: T;
  toVerbatimString?(asLiteral: boolean): string;
  map<U>(fn: (x: T) => U): U[];
}
interface DafnySet<T = unknown> { readonly Elements: Iterable<T>; }
interface DafnyMap<K = unknown, V = unknown> {
  readonly Keys: DafnySet<K>;
  get(key: K): V;
  contains(key: K): boolean;
}

interface DafnyExpense {
  readonly is_Expense: true;
  readonly dtor_paidBy: DafnySeq;
  readonly dtor_amount: DafnyInt;
  readonly dtor_shares: DafnyMap<DafnySeq, DafnyInt>;
  readonly dtor_shareKeys: DafnySeq<DafnySeq>;
}

interface DafnySettlement {
  readonly is_Settlement: true;
  readonly dtor_from: DafnySeq;
  readonly dtor_to: DafnySeq;
  readonly dtor_amount: DafnyInt;
}

interface DafnyModel {
  readonly is_Model: true;
  readonly dtor_members: DafnySet<DafnySeq>;
  readonly dtor_memberList: DafnySeq<DafnySeq>;
  readonly dtor_expenses: DafnySeq<DafnyExpense>;
  readonly dtor_settlements: DafnySeq<DafnySettlement>;
}

type DafnyResult<T, E> = { readonly is_Ok: true; readonly is_Error: false; readonly dtor_value: T } | { readonly is_Ok: false; readonly is_Error: true; readonly dtor_error: E };

type DafnyErr = { readonly is_NotMember: true; readonly is_BadExpense: false; readonly is_BadSettlement: false; readonly dtor_p: DafnySeq } | { readonly is_NotMember: false; readonly is_BadExpense: true; readonly is_BadSettlement: false } | { readonly is_NotMember: false; readonly is_BadExpense: false; readonly is_BadSettlement: true };

type DafnyAction = { readonly is_AddExpense: true; readonly is_AddSettlement: false; readonly dtor_e: DafnyExpense } | { readonly is_AddExpense: false; readonly is_AddSettlement: true; readonly dtor_s: DafnySettlement };

interface DafnyCertificate {
  readonly is_Certificate: true;
  readonly dtor_memberCount: DafnyInt;
  readonly dtor_expenseCount: DafnyInt;
  readonly dtor_settlementCount: DafnyInt;
  readonly dtor_conservationHolds: boolean;
}

interface DafnyRejectReason {
  readonly is_DomainInvalid: true;
}

type DafnyReply = { readonly is_Accepted: true; readonly is_Rejected: false; readonly dtor_newVersion: DafnyInt; readonly dtor_newPresent: DafnyModel; readonly dtor_applied: DafnyAction; readonly dtor_noChange: boolean } | { readonly is_Accepted: false; readonly is_Rejected: true; readonly dtor_reason: DafnyRejectReason; readonly dtor_rebased: DafnyAction };

type DafnyRequestOutcome = { readonly is_AuditAccepted: true; readonly is_AuditRejected: false; readonly dtor_applied: DafnyAction; readonly dtor_noChange: boolean } | { readonly is_AuditAccepted: false; readonly is_AuditRejected: true; readonly dtor_reason: DafnyRejectReason; readonly dtor_rebased: DafnyAction };

interface DafnyRequestRecord {
  readonly is_Req: true;
  readonly dtor_baseVersion: DafnyInt;
  readonly dtor_orig: DafnyAction;
  readonly dtor_rebased: DafnyAction;
  readonly dtor_chosen: DafnyAction;
  readonly dtor_outcome: DafnyRequestOutcome;
}

interface DafnyServerState {
  readonly is_ServerState: true;
  readonly dtor_present: DafnyModel;
  readonly dtor_appliedLog: DafnySeq<DafnyAction>;
  readonly dtor_auditLog: DafnySeq<DafnyRequestRecord>;
}

interface DafnyClientState {
  readonly is_ClientState: true;
  readonly dtor_baseVersion: DafnyInt;
  readonly dtor_present: DafnyModel;
  readonly dtor_pending: DafnySeq<DafnyAction>;
}

type DafnyNetworkStatus = { readonly is_Online: true; readonly is_Offline: false } | { readonly is_Online: false; readonly is_Offline: true };

type DafnyEffectMode = { readonly is_Idle: true; readonly is_Dispatching: false } | { readonly is_Idle: false; readonly is_Dispatching: true; readonly dtor_retries: DafnyInt };

interface DafnyEffectState {
  readonly is_EffectState: true;
  readonly dtor_network: DafnyNetworkStatus;
  readonly dtor_mode: DafnyEffectMode;
  readonly dtor_client: DafnyClientState;
  readonly dtor_serverVersion: DafnyInt;
}

type DafnyEvent = { readonly is_UserAction: true; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false; readonly dtor_action: DafnyAction } | { readonly is_UserAction: false; readonly is_DispatchAccepted: true; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false; readonly dtor_newVersion: DafnyInt; readonly dtor_newModel: DafnyModel } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: true; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false; readonly dtor_freshVersion: DafnyInt; readonly dtor_freshModel: DafnyModel } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: true; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false; readonly dtor_freshVersion: DafnyInt; readonly dtor_freshModel: DafnyModel } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: true; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: true; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: false } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: true; readonly is_ManualGoOnline: false; readonly is_Tick: false } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: true; readonly is_Tick: false } | { readonly is_UserAction: false; readonly is_DispatchAccepted: false; readonly is_DispatchConflict: false; readonly is_DispatchRejected: false; readonly is_NetworkError: false; readonly is_NetworkRestored: false; readonly is_ManualGoOffline: false; readonly is_ManualGoOnline: false; readonly is_Tick: true };

type DafnyCommand = { readonly is_NoOp: true; readonly is_SendDispatch: false; readonly is_FetchFreshState: false } | { readonly is_NoOp: false; readonly is_SendDispatch: true; readonly is_FetchFreshState: false; readonly dtor_baseVersion: DafnyInt; readonly dtor_action: DafnyAction } | { readonly is_NoOp: false; readonly is_SendDispatch: false; readonly is_FetchFreshState: true };

interface DafnyGroupEntry {
  readonly is_GroupEntry: true;
  readonly dtor_groupName: DafnySeq;
  readonly dtor_displayName: DafnySeq;
  readonly dtor_model: DafnyModel;
}

interface DafnyGroupBalance {
  readonly is_GroupBalance: true;
  readonly dtor_groupName: DafnySeq;
  readonly dtor_balance: DafnyInt;
}

interface DafnyCrossGroupSummary {
  readonly is_CrossGroupSummary: true;
  readonly dtor_totalOwed: DafnyInt;
  readonly dtor_totalOwes: DafnyInt;
  readonly dtor_netBalance: DafnyInt;
  readonly dtor_groups: DafnySeq<DafnyGroupBalance>;
}

// ============================================================================
// Datatype Conversions
// ============================================================================

// deno-lint-ignore no-explicit-any
const expenseFromJson = (json: any): DafnyExpense => {
  let __shares = _dafny.Map.Empty;
  for (const [k, v] of (Object.entries(json.shares || {}) as [string, any][])) {
    const key = _dafny.Seq.UnicodeFromString(k);
    const val = new BigNumber(v);
    __shares = __shares.update(key, val);
  }
  return ClearSplit.Expense.create_Expense(
    _dafny.Seq.UnicodeFromString(json.paidBy),
    new BigNumber(json.amount),
    __shares,
    _dafny.Seq.of(...(json.shareKeys || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))
  );
};

// deno-lint-ignore no-explicit-any
const expenseToJson = (value: any): Expense => {
  const __sharesJson: Record<string, any> = {};
  if (value.dtor_shares && value.dtor_shares.Keys) {
    for (const k of value.dtor_shares.Keys.Elements) {
      const v = value.dtor_shares.get(k);
      __sharesJson[dafnyStringToJs(k)] = toNumber(v);
    }
  }
  return {
    paidBy: dafnyStringToJs(value.dtor_paidBy),
    amount: toNumber(value.dtor_amount),
    shares: __sharesJson,
    shareKeys: seqToArray(value.dtor_shareKeys).map((x: any) => dafnyStringToJs(x))
  };
};

// deno-lint-ignore no-explicit-any
const settlementFromJson = (json: any): DafnySettlement => {
  return ClearSplit.Settlement.create_Settlement(
    _dafny.Seq.UnicodeFromString(json.from),
    _dafny.Seq.UnicodeFromString(json.to),
    new BigNumber(json.amount)
  );
};

// deno-lint-ignore no-explicit-any
const settlementToJson = (value: any): Settlement => {
  return {
    from: dafnyStringToJs(value.dtor_from),
    to: dafnyStringToJs(value.dtor_to),
    amount: toNumber(value.dtor_amount)
  };
};

// deno-lint-ignore no-explicit-any
const modelFromJson = (json: any): DafnyModel => {
  return ClearSplit.Model.create_Model(
    _dafny.Set.fromElements(...(json.members || []).map((x: any) => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Seq.of(...(json.memberList || []).map((x: any) => _dafny.Seq.UnicodeFromString(x))),
    _dafny.Seq.of(...(json.expenses || []).map((x: any) => expenseFromJson(x))),
    _dafny.Seq.of(...(json.settlements || []).map((x: any) => settlementFromJson(x)))
  );
};

// deno-lint-ignore no-explicit-any
const modelToJson = (value: any): Model => {
  return {
    members: Array.from(value.dtor_members.Elements).map((x: any) => dafnyStringToJs(x)),
    memberList: seqToArray(value.dtor_memberList).map((x: any) => dafnyStringToJs(x)),
    expenses: seqToArray(value.dtor_expenses).map((x: any) => expenseToJson(x)),
    settlements: seqToArray(value.dtor_settlements).map((x: any) => settlementToJson(x))
  };
};

// deno-lint-ignore no-explicit-any
const resultFromJson = <T, E>(json: any, T_fromJson: (x: any) => T, E_fromJson: (x: any) => E): DafnyResult<T, E> => {
  switch (json.type) {
    case 'Ok': {
      return ClearSplit.Result.create_Ok(
        T_fromJson(json.value)
      );
    }
    case 'Error': {
      return ClearSplit.Result.create_Error(
        E_fromJson(json.error)
      );
    }
    default:
      throw new Error(`Unknown Result type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const resultToJson = <T, E>(value: any, T_toJson: (x: any) => any, E_toJson: (x: any) => any): Result<T, E> => {
  if (value.is_Ok) {
    return {
      type: 'Ok',
      value: T_toJson(value.dtor_value)
    };
  } else if (value.is_Error) {
    return {
      type: 'Error',
      error: E_toJson(value.dtor_error)
    };
  }
  throw new Error('Unknown Result variant');
};

// deno-lint-ignore no-explicit-any
const errFromJson = (json: any): DafnyErr => {
  switch (json.type) {
    case 'NotMember': {
      return ClearSplit.Err.create_NotMember(
        _dafny.Seq.UnicodeFromString(json.p)
      );
    }
    case 'BadExpense': {
      return ClearSplit.Err.create_BadExpense();
    }
    case 'BadSettlement': {
      return ClearSplit.Err.create_BadSettlement();
    }
    default:
      throw new Error(`Unknown Err type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const errToJson = (value: any): Err => {
  if (value.is_NotMember) {
    return {
      type: 'NotMember',
      p: dafnyStringToJs(value.dtor_p)
    };
  } else if (value.is_BadExpense) {
    return { type: 'BadExpense' };
  } else if (value.is_BadSettlement) {
    return { type: 'BadSettlement' };
  }
  throw new Error('Unknown Err variant');
};

// deno-lint-ignore no-explicit-any
const actionFromJson = (json: any): DafnyAction => {
  switch (json.type) {
    case 'AddExpense': {
      return ClearSplit.Action.create_AddExpense(
        expenseFromJson(json.e)
      );
    }
    case 'AddSettlement': {
      return ClearSplit.Action.create_AddSettlement(
        settlementFromJson(json.s)
      );
    }
    default:
      throw new Error(`Unknown Action type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const actionToJson = (value: any): Action => {
  if (value.is_AddExpense) {
    return {
      type: 'AddExpense',
      e: expenseToJson(value.dtor_e)
    };
  } else if (value.is_AddSettlement) {
    return {
      type: 'AddSettlement',
      s: settlementToJson(value.dtor_s)
    };
  }
  throw new Error('Unknown Action variant');
};

// deno-lint-ignore no-explicit-any
const certificateFromJson = (json: any): DafnyCertificate => {
  return ClearSplit.Certificate.create_Certificate(
    new BigNumber(json.memberCount),
    new BigNumber(json.expenseCount),
    new BigNumber(json.settlementCount),
    json.conservationHolds
  );
};

// deno-lint-ignore no-explicit-any
const certificateToJson = (value: any): Certificate => {
  return {
    memberCount: toNumber(value.dtor_memberCount),
    expenseCount: toNumber(value.dtor_expenseCount),
    settlementCount: toNumber(value.dtor_settlementCount),
    conservationHolds: value.dtor_conservationHolds
  };
};

// deno-lint-ignore no-explicit-any
const rejectreasonFromJson = (json: any): DafnyRejectReason => {
  return ClearSplitMultiCollaboration.RejectReason.create_DomainInvalid();
};

// deno-lint-ignore no-explicit-any
const rejectreasonToJson = (value: any): RejectReason => {
  return {};
};

// deno-lint-ignore no-explicit-any
const replyFromJson = (json: any): DafnyReply => {
  switch (json.type) {
    case 'Accepted': {
      return ClearSplitMultiCollaboration.Reply.create_Accepted(
        new BigNumber(json.newVersion),
        modelFromJson(json.newPresent),
        actionFromJson(json.applied),
        json.noChange
      );
    }
    case 'Rejected': {
      return ClearSplitMultiCollaboration.Reply.create_Rejected(
        rejectreasonFromJson(json.reason),
        actionFromJson(json.rebased)
      );
    }
    default:
      throw new Error(`Unknown Reply type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const replyToJson = (value: any): Reply => {
  if (value.is_Accepted) {
    return {
      type: 'Accepted',
      newVersion: toNumber(value.dtor_newVersion),
      newPresent: modelToJson(value.dtor_newPresent),
      applied: actionToJson(value.dtor_applied),
      noChange: value.dtor_noChange
    };
  } else if (value.is_Rejected) {
    return {
      type: 'Rejected',
      reason: rejectreasonToJson(value.dtor_reason),
      rebased: actionToJson(value.dtor_rebased)
    };
  }
  throw new Error('Unknown Reply variant');
};

// deno-lint-ignore no-explicit-any
const requestoutcomeFromJson = (json: any): DafnyRequestOutcome => {
  switch (json.type) {
    case 'AuditAccepted': {
      return ClearSplitMultiCollaboration.RequestOutcome.create_AuditAccepted(
        actionFromJson(json.applied),
        json.noChange
      );
    }
    case 'AuditRejected': {
      return ClearSplitMultiCollaboration.RequestOutcome.create_AuditRejected(
        rejectreasonFromJson(json.reason),
        actionFromJson(json.rebased)
      );
    }
    default:
      throw new Error(`Unknown RequestOutcome type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const requestoutcomeToJson = (value: any): RequestOutcome => {
  if (value.is_AuditAccepted) {
    return {
      type: 'AuditAccepted',
      applied: actionToJson(value.dtor_applied),
      noChange: value.dtor_noChange
    };
  } else if (value.is_AuditRejected) {
    return {
      type: 'AuditRejected',
      reason: rejectreasonToJson(value.dtor_reason),
      rebased: actionToJson(value.dtor_rebased)
    };
  }
  throw new Error('Unknown RequestOutcome variant');
};

// deno-lint-ignore no-explicit-any
const requestrecordFromJson = (json: any): DafnyRequestRecord => {
  return ClearSplitMultiCollaboration.RequestRecord.create_Req(
    new BigNumber(json.baseVersion),
    actionFromJson(json.orig),
    actionFromJson(json.rebased),
    actionFromJson(json.chosen),
    requestoutcomeFromJson(json.outcome)
  );
};

// deno-lint-ignore no-explicit-any
const requestrecordToJson = (value: any): RequestRecord => {
  return {
    baseVersion: toNumber(value.dtor_baseVersion),
    orig: actionToJson(value.dtor_orig),
    rebased: actionToJson(value.dtor_rebased),
    chosen: actionToJson(value.dtor_chosen),
    outcome: requestoutcomeToJson(value.dtor_outcome)
  };
};

// deno-lint-ignore no-explicit-any
const serverstateFromJson = (json: any): DafnyServerState => {
  return ClearSplitMultiCollaboration.ServerState.create_ServerState(
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.appliedLog || []).map((x: any) => actionFromJson(x))),
    _dafny.Seq.of(...(json.auditLog || []).map((x: any) => requestrecordFromJson(x)))
  );
};

// deno-lint-ignore no-explicit-any
const serverstateToJson = (value: any): ServerState => {
  return {
    present: modelToJson(value.dtor_present),
    appliedLog: seqToArray(value.dtor_appliedLog).map((x: any) => actionToJson(x)),
    auditLog: seqToArray(value.dtor_auditLog).map((x: any) => requestrecordToJson(x))
  };
};

// deno-lint-ignore no-explicit-any
const clientstateFromJson = (json: any): DafnyClientState => {
  return ClearSplitMultiCollaboration.ClientState.create_ClientState(
    new BigNumber(json.baseVersion),
    modelFromJson(json.present),
    _dafny.Seq.of(...(json.pending || []).map((x: any) => actionFromJson(x)))
  );
};

// deno-lint-ignore no-explicit-any
const clientstateToJson = (value: any): ClientState => {
  return {
    baseVersion: toNumber(value.dtor_baseVersion),
    present: modelToJson(value.dtor_present),
    pending: seqToArray(value.dtor_pending).map((x: any) => actionToJson(x))
  };
};

// deno-lint-ignore no-explicit-any
const networkstatusFromJson = (json: any): DafnyNetworkStatus => {
  switch (json) {
    case 'Online':
      return ClearSplitEffectStateMachine.NetworkStatus.create_Online();
    case 'Offline':
      return ClearSplitEffectStateMachine.NetworkStatus.create_Offline();
    default:
      throw new Error(`Unknown NetworkStatus: ${json}`);
  }
};

// deno-lint-ignore no-explicit-any
const networkstatusToJson = (value: any): NetworkStatus => {
  if (value.is_Online) {
    return 'Online';
  } else if (value.is_Offline) {
    return 'Offline';
  }
  throw new Error('Unknown NetworkStatus variant');
};

// deno-lint-ignore no-explicit-any
const effectmodeFromJson = (json: any): DafnyEffectMode => {
  switch (json.type) {
    case 'Idle': {
      return ClearSplitEffectStateMachine.EffectMode.create_Idle();
    }
    case 'Dispatching': {
      return ClearSplitEffectStateMachine.EffectMode.create_Dispatching(
        new BigNumber(json.retries)
      );
    }
    default:
      throw new Error(`Unknown EffectMode type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const effectmodeToJson = (value: any): EffectMode => {
  if (value.is_Idle) {
    return { type: 'Idle' };
  } else if (value.is_Dispatching) {
    return {
      type: 'Dispatching',
      retries: toNumber(value.dtor_retries)
    };
  }
  throw new Error('Unknown EffectMode variant');
};

// deno-lint-ignore no-explicit-any
const effectstateFromJson = (json: any): DafnyEffectState => {
  return ClearSplitEffectStateMachine.EffectState.create_EffectState(
    networkstatusFromJson(json.network),
    effectmodeFromJson(json.mode),
    clientstateFromJson(json.client),
    new BigNumber(json.serverVersion)
  );
};

// deno-lint-ignore no-explicit-any
const effectstateToJson = (value: any): EffectState => {
  return {
    network: networkstatusToJson(value.dtor_network),
    mode: effectmodeToJson(value.dtor_mode),
    client: clientstateToJson(value.dtor_client),
    serverVersion: toNumber(value.dtor_serverVersion)
  };
};

// deno-lint-ignore no-explicit-any
const eventFromJson = (json: any): DafnyEvent => {
  switch (json.type) {
    case 'UserAction': {
      return ClearSplitEffectStateMachine.Event.create_UserAction(
        actionFromJson(json.action)
      );
    }
    case 'DispatchAccepted': {
      return ClearSplitEffectStateMachine.Event.create_DispatchAccepted(
        new BigNumber(json.newVersion),
        modelFromJson(json.newModel)
      );
    }
    case 'DispatchConflict': {
      return ClearSplitEffectStateMachine.Event.create_DispatchConflict(
        new BigNumber(json.freshVersion),
        modelFromJson(json.freshModel)
      );
    }
    case 'DispatchRejected': {
      return ClearSplitEffectStateMachine.Event.create_DispatchRejected(
        new BigNumber(json.freshVersion),
        modelFromJson(json.freshModel)
      );
    }
    case 'NetworkError': {
      return ClearSplitEffectStateMachine.Event.create_NetworkError();
    }
    case 'NetworkRestored': {
      return ClearSplitEffectStateMachine.Event.create_NetworkRestored();
    }
    case 'ManualGoOffline': {
      return ClearSplitEffectStateMachine.Event.create_ManualGoOffline();
    }
    case 'ManualGoOnline': {
      return ClearSplitEffectStateMachine.Event.create_ManualGoOnline();
    }
    case 'Tick': {
      return ClearSplitEffectStateMachine.Event.create_Tick();
    }
    default:
      throw new Error(`Unknown Event type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const eventToJson = (value: any): Event => {
  if (value.is_UserAction) {
    return {
      type: 'UserAction',
      action: actionToJson(value.dtor_action)
    };
  } else if (value.is_DispatchAccepted) {
    return {
      type: 'DispatchAccepted',
      newVersion: toNumber(value.dtor_newVersion),
      newModel: modelToJson(value.dtor_newModel)
    };
  } else if (value.is_DispatchConflict) {
    return {
      type: 'DispatchConflict',
      freshVersion: toNumber(value.dtor_freshVersion),
      freshModel: modelToJson(value.dtor_freshModel)
    };
  } else if (value.is_DispatchRejected) {
    return {
      type: 'DispatchRejected',
      freshVersion: toNumber(value.dtor_freshVersion),
      freshModel: modelToJson(value.dtor_freshModel)
    };
  } else if (value.is_NetworkError) {
    return { type: 'NetworkError' };
  } else if (value.is_NetworkRestored) {
    return { type: 'NetworkRestored' };
  } else if (value.is_ManualGoOffline) {
    return { type: 'ManualGoOffline' };
  } else if (value.is_ManualGoOnline) {
    return { type: 'ManualGoOnline' };
  } else if (value.is_Tick) {
    return { type: 'Tick' };
  }
  throw new Error('Unknown Event variant');
};

// deno-lint-ignore no-explicit-any
const commandFromJson = (json: any): DafnyCommand => {
  switch (json.type) {
    case 'NoOp': {
      return ClearSplitEffectStateMachine.Command.create_NoOp();
    }
    case 'SendDispatch': {
      return ClearSplitEffectStateMachine.Command.create_SendDispatch(
        new BigNumber(json.baseVersion),
        actionFromJson(json.action)
      );
    }
    case 'FetchFreshState': {
      return ClearSplitEffectStateMachine.Command.create_FetchFreshState();
    }
    default:
      throw new Error(`Unknown Command type: ${json.type}`);
  }
};

// deno-lint-ignore no-explicit-any
const commandToJson = (value: any): Command => {
  if (value.is_NoOp) {
    return { type: 'NoOp' };
  } else if (value.is_SendDispatch) {
    return {
      type: 'SendDispatch',
      baseVersion: toNumber(value.dtor_baseVersion),
      action: actionToJson(value.dtor_action)
    };
  } else if (value.is_FetchFreshState) {
    return { type: 'FetchFreshState' };
  }
  throw new Error('Unknown Command variant');
};

// deno-lint-ignore no-explicit-any
const groupentryFromJson = (json: any): DafnyGroupEntry => {
  return ClearSplitCrossGroup.GroupEntry.create_GroupEntry(
    _dafny.Seq.UnicodeFromString(json.groupName),
    _dafny.Seq.UnicodeFromString(json.displayName),
    modelFromJson(json.model)
  );
};

// deno-lint-ignore no-explicit-any
const groupentryToJson = (value: any): GroupEntry => {
  return {
    groupName: dafnyStringToJs(value.dtor_groupName),
    displayName: dafnyStringToJs(value.dtor_displayName),
    model: modelToJson(value.dtor_model)
  };
};

// deno-lint-ignore no-explicit-any
const groupbalanceFromJson = (json: any): DafnyGroupBalance => {
  return ClearSplitCrossGroup.GroupBalance.create_GroupBalance(
    _dafny.Seq.UnicodeFromString(json.groupName),
    new BigNumber(json.balance)
  );
};

// deno-lint-ignore no-explicit-any
const groupbalanceToJson = (value: any): GroupBalance => {
  return {
    groupName: dafnyStringToJs(value.dtor_groupName),
    balance: toNumber(value.dtor_balance)
  };
};

// deno-lint-ignore no-explicit-any
const crossgroupsummaryFromJson = (json: any): DafnyCrossGroupSummary => {
  return ClearSplitCrossGroup.CrossGroupSummary.create_CrossGroupSummary(
    new BigNumber(json.totalOwed),
    new BigNumber(json.totalOwes),
    new BigNumber(json.netBalance),
    _dafny.Seq.of(...(json.groups || []).map((x: any) => groupbalanceFromJson(x)))
  );
};

// deno-lint-ignore no-explicit-any
const crossgroupsummaryToJson = (value: any): CrossGroupSummary => {
  return {
    totalOwed: toNumber(value.dtor_totalOwed),
    totalOwes: toNumber(value.dtor_totalOwes),
    netBalance: toNumber(value.dtor_netBalance),
    groups: seqToArray(value.dtor_groups).map((x: any) => groupbalanceToJson(x))
  };
};

// ============================================================================
// API Wrapper
// ============================================================================

interface AppInternal { _dafny: unknown; ClearSplit: unknown; ClearSplitMultiCollaboration: unknown; ClearSplitEffectStateMachine: unknown; ClearSplitCrossGroup: unknown; ClearSplitEffectAppCore: unknown; }

const App = {
  // Expense constructors
  Expense: (paidBy: string, amount: number, shares: Record<string, number>, shareKeys: string[]) => ClearSplit.Expense.create_Expense(_dafny.Seq.UnicodeFromString(paidBy), new BigNumber(amount), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(shares), _dafny.Seq.of(...(shareKeys || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))),

  // Settlement constructors
  Settlement: (from: string, to: string, amount: number) => ClearSplit.Settlement.create_Settlement(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to), new BigNumber(amount)),

  // Result constructors
  Ok: (value: unknown) => ClearSplit.Result.create_Ok(value),
  Error: (error: unknown) => ClearSplit.Result.create_Error(error),

  // Err constructors
  NotMember: (p: string) => ClearSplit.Err.create_NotMember(_dafny.Seq.UnicodeFromString(p)),
  BadExpense: () => ClearSplit.Err.create_BadExpense(),
  BadSettlement: () => ClearSplit.Err.create_BadSettlement(),

  // Certificate constructors
  Certificate: (memberCount: number, expenseCount: number, settlementCount: number, conservationHolds: boolean) => ClearSplit.Certificate.create_Certificate(new BigNumber(memberCount), new BigNumber(expenseCount), new BigNumber(settlementCount), conservationHolds),

  // Action constructors
  AddExpense: (e: DafnyExpense) => ClearSplit.Action.create_AddExpense(e),
  AddSettlement: (s: DafnySettlement) => ClearSplit.Action.create_AddSettlement(s),

  // Model accessors
  GetMembers: (m: DafnyModel) => Array.from(m.dtor_members.Elements).map((x: any) => dafnyStringToJs(x)),
  GetMemberList: (m: DafnyModel) => seqToArray(m.dtor_memberList).map((x: any) => dafnyStringToJs(x)),
  GetExpenses: (m: DafnyModel) => seqToArray(m.dtor_expenses).map((x: any) => expenseToJson(x)),
  GetSettlements: (m: DafnyModel) => seqToArray(m.dtor_settlements).map((x: any) => settlementToJson(x)),

  // AppCore functions
  EffectInit: (version: number, model: DafnyModel) => ClearSplitEffectAppCore.__default.EffectInit(new BigNumber(version), model),
  EffectStep: (es: DafnyEffectState, event: DafnyEvent) => ClearSplitEffectAppCore.__default.EffectStep(es, event),
  EffectIsOnline: (es: DafnyEffectState) => ClearSplitEffectAppCore.__default.EffectIsOnline(es),
  EffectIsIdle: (es: DafnyEffectState) => ClearSplitEffectAppCore.__default.EffectIsIdle(es),
  EffectHasPending: (es: DafnyEffectState) => ClearSplitEffectAppCore.__default.EffectHasPending(es),
  EffectPendingCount: (es: DafnyEffectState) => toNumber(ClearSplitEffectAppCore.__default.EffectPendingCount(es)),
  EffectGetClient: (es: DafnyEffectState) => ClearSplitEffectAppCore.__default.EffectGetClient(es),
  EffectGetServerVersion: (es: DafnyEffectState) => toNumber(ClearSplitEffectAppCore.__default.EffectGetServerVersion(es)),
  EffectUserAction: (action: DafnyAction) => ClearSplitEffectAppCore.__default.EffectUserAction(action),
  EffectDispatchAccepted: (version: number, model: DafnyModel) => ClearSplitEffectAppCore.__default.EffectDispatchAccepted(new BigNumber(version), model),
  EffectDispatchConflict: (version: number, model: DafnyModel) => ClearSplitEffectAppCore.__default.EffectDispatchConflict(new BigNumber(version), model),
  EffectDispatchRejected: (version: number, model: DafnyModel) => ClearSplitEffectAppCore.__default.EffectDispatchRejected(new BigNumber(version), model),
  EffectNetworkError: () => ClearSplitEffectAppCore.__default.EffectNetworkError(),
  EffectNetworkRestored: () => ClearSplitEffectAppCore.__default.EffectNetworkRestored(),
  EffectManualGoOffline: () => ClearSplitEffectAppCore.__default.EffectManualGoOffline(),
  EffectManualGoOnline: () => ClearSplitEffectAppCore.__default.EffectManualGoOnline(),
  EffectTick: () => ClearSplitEffectAppCore.__default.EffectTick(),
  EffectIsNoOp: (cmd: DafnyCommand) => ClearSplitEffectAppCore.__default.EffectIsNoOp(cmd),
  EffectIsSendDispatch: (cmd: DafnyCommand) => ClearSplitEffectAppCore.__default.EffectIsSendDispatch(cmd),
  EffectGetBaseVersion: (cmd: DafnyCommand) => toNumber(ClearSplitEffectAppCore.__default.EffectGetBaseVersion(cmd)),
  EffectGetAction: (cmd: DafnyCommand) => ClearSplitEffectAppCore.__default.EffectGetAction(cmd),
  MakeGroupEntry: (groupName: string, displayName: string, model: DafnyModel) => ClearSplitEffectAppCore.__default.MakeGroupEntry(_dafny.Seq.UnicodeFromString(groupName), _dafny.Seq.UnicodeFromString(displayName), model),
  ComputeCrossGroupSummary: (groups: GroupEntry[]) => ClearSplitEffectAppCore.__default.ComputeCrossGroupSummary(_dafny.Seq.of(...(groups || []).map((x: any) => groupentryFromJson(x)))),
  GetTotalOwed: (summary: DafnyCrossGroupSummary) => toNumber(ClearSplitEffectAppCore.__default.GetTotalOwed(summary)),
  GetTotalOwes: (summary: DafnyCrossGroupSummary) => toNumber(ClearSplitEffectAppCore.__default.GetTotalOwes(summary)),
  GetNetBalance: (summary: DafnyCrossGroupSummary) => toNumber(ClearSplitEffectAppCore.__default.GetNetBalance(summary)),
  GetGroupBalances: (summary: DafnyCrossGroupSummary) => seqToArray(ClearSplitEffectAppCore.__default.GetGroupBalances(summary)).map(x => groupbalanceToJson(x)),
  GetGroupBalanceName: (gb: DafnyGroupBalance) => dafnyStringToJs(ClearSplitEffectAppCore.__default.GetGroupBalanceName(gb)),
  GetGroupBalanceAmount: (gb: DafnyGroupBalance) => toNumber(ClearSplitEffectAppCore.__default.GetGroupBalanceAmount(gb)),
  InitServerWithMembers: (memberList: string[]) => ClearSplitEffectAppCore.__default.InitServerWithMembers(_dafny.Seq.of(...(memberList || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))),
  InitClientFromServer: (server: DafnyServerState) => ClearSplitEffectAppCore.__default.InitClientFromServer(server),
  InitClient: (version: number, model: DafnyModel) => ClearSplitEffectAppCore.__default.InitClient(new BigNumber(version), model),
  MakeExpense: (paidBy: string, amount: number, shares: Record<string, number>, shareKeys: string[]) => ClearSplitEffectAppCore.__default.MakeExpense(_dafny.Seq.UnicodeFromString(paidBy), new BigNumber(amount), ((obj) => { let m = _dafny.Map.Empty; for (const [k, v] of Object.entries(obj || {})) { m = m.update(_dafny.Seq.UnicodeFromString(k), new BigNumber(v)); } return m; })(shares), _dafny.Seq.of(...(shareKeys || []).map((x: any) => _dafny.Seq.UnicodeFromString(x)))),
  MakeSettlement: (from: string, to: string, amount: number) => ClearSplitEffectAppCore.__default.MakeSettlement(_dafny.Seq.UnicodeFromString(from), _dafny.Seq.UnicodeFromString(to), new BigNumber(amount)),
  ClientLocalDispatch: (client: DafnyClientState, action: DafnyAction) => ClearSplitEffectAppCore.__default.ClientLocalDispatch(client, action),
  HandleRealtimeUpdate: (client: DafnyClientState, serverVersion: number, serverModel: DafnyModel) => ClearSplitEffectAppCore.__default.HandleRealtimeUpdate(client, new BigNumber(serverVersion), serverModel),
  ClientAcceptReply: (client: DafnyClientState, newVersion: number, newPresent: DafnyModel) => ClearSplitEffectAppCore.__default.ClientAcceptReply(client, new BigNumber(newVersion), newPresent),
  ClientRejectReply: (client: DafnyClientState, freshVersion: number, freshModel: DafnyModel) => ClearSplitEffectAppCore.__default.ClientRejectReply(client, new BigNumber(freshVersion), freshModel),
  ServerDispatch: (server: DafnyServerState, baseVersion: number, action: DafnyAction) => ClearSplitEffectAppCore.__default.ServerDispatch(server, new BigNumber(baseVersion), action),
  ServerVersion: (server: DafnyServerState) => toNumber(ClearSplitEffectAppCore.__default.ServerVersion(server)),
  ClientModel: (client: DafnyClientState) => ClearSplitEffectAppCore.__default.ClientModel(client),
  ClientVersion: (client: DafnyClientState) => toNumber(ClearSplitEffectAppCore.__default.ClientVersion(client)),
  PendingCount: (client: DafnyClientState) => toNumber(ClearSplitEffectAppCore.__default.PendingCount(client)),
  IsAccepted: (reply: DafnyReply) => ClearSplitEffectAppCore.__default.IsAccepted(reply),
  IsRejected: (reply: DafnyReply) => ClearSplitEffectAppCore.__default.IsRejected(reply),
  Balances: (model: DafnyModel) => ClearSplitEffectAppCore.__default.Balances(model),
  GetBalance: (model: DafnyModel, p: string) => toNumber(ClearSplitEffectAppCore.__default.GetBalance(model, _dafny.Seq.UnicodeFromString(p))),
  Members: (model: DafnyModel) => seqToArray(ClearSplitEffectAppCore.__default.Members(model)).map(x => dafnyStringToJs(x)),
  Expenses: (model: DafnyModel) => seqToArray(ClearSplitEffectAppCore.__default.Expenses(model)).map(x => expenseToJson(x)),
  Settlements: (model: DafnyModel) => seqToArray(ClearSplitEffectAppCore.__default.Settlements(model)).map(x => settlementToJson(x)),
  GetFirstPending: (client: DafnyClientState) => ClearSplitEffectAppCore.__default.GetFirstPending(client),
  HasPending: (client: DafnyClientState) => ClearSplitEffectAppCore.__default.HasPending(client),

  // Conversion functions
  expenseToJson,
  expenseFromJson,
  settlementToJson,
  settlementFromJson,
  modelToJson,
  modelFromJson,
  resultToJson,
  resultFromJson,
  errToJson,
  errFromJson,
  actionToJson,
  actionFromJson,
  certificateToJson,
  certificateFromJson,
  rejectreasonToJson,
  rejectreasonFromJson,
  replyToJson,
  replyFromJson,
  requestoutcomeToJson,
  requestoutcomeFromJson,
  requestrecordToJson,
  requestrecordFromJson,
  serverstateToJson,
  serverstateFromJson,
  clientstateToJson,
  clientstateFromJson,
  networkstatusToJson,
  networkstatusFromJson,
  effectmodeToJson,
  effectmodeFromJson,
  effectstateToJson,
  effectstateFromJson,
  eventToJson,
  eventFromJson,
  commandToJson,
  commandFromJson,
  groupentryToJson,
  groupentryFromJson,
  groupbalanceToJson,
  groupbalanceFromJson,
  crossgroupsummaryToJson,
  crossgroupsummaryFromJson,

  // Internal modules for custom extensions
  _internal: { _dafny, ClearSplit, ClearSplitMultiCollaboration, ClearSplitEffectStateMachine, ClearSplitCrossGroup, ClearSplitEffectAppCore } as AppInternal,
};

export default App;
