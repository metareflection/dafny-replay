// Dispatch endpoint for verified Dafny state transitions
// Uses compiled Dafny code for ClearSplit dispatch

import { Hono } from 'hono'
import { broadcastUpdate } from '@dafny-replay/cloudflare'
import type { Env, Variables } from './index'

// Import from compiled Dafny bundle (will be generated by compile.sh)
import { dispatch } from './dafny-bundle'

export const dispatchRoutes = new Hono<{ Bindings: Env; Variables: Variables }>()

// ============================================================================
// Single-Group Dispatch
// ============================================================================

dispatchRoutes.post('/dispatch', async (c) => {
  const userId = c.get('userId')
  const { groupId, baseVersion, action } = await c.req.json<{
    groupId: string
    baseVersion: number
    action: any
  }>()

  if (!groupId) {
    return c.json({ error: 'groupId is required' }, 400)
  }

  // Check membership
  const member = await c.env.DB.prepare(
    'SELECT role FROM group_members WHERE group_id = ? AND user_id = ?'
  ).bind(groupId, userId).first()

  if (!member) {
    return c.json({ error: 'Not a member of this group' }, 403)
  }

  // Load current group state
  const group = await c.env.DB.prepare(
    'SELECT state, version, applied_log, audit_log FROM groups WHERE id = ?'
  ).bind(groupId).first<{
    state: string
    version: number
    applied_log: string
    audit_log: string
  }>()

  if (!group) {
    return c.json({ error: 'Group not found' }, 404)
  }

  // Validate baseVersion
  if (baseVersion > group.version) {
    return c.json({ error: 'Invalid base version' }, 400)
  }

  // Parse stored JSON
  const state = JSON.parse(group.state)
  const appliedLog = JSON.parse(group.applied_log)
  const auditLog = JSON.parse(group.audit_log)

  // ========================================================================
  // Run VERIFIED Dafny Dispatch
  // ========================================================================

  let result
  try {
    result = dispatch(state, appliedLog, baseVersion, action, auditLog)
  } catch (e) {
    console.error('Dispatch call failed:', e)
    return c.json({
      error: 'Dispatch failed',
      details: String(e)
    }, 500)
  }

  if (result.status === 'rejected') {
    return c.json({
      status: 'rejected',
      reason: result.reason || 'No valid interpretation of action'
    })
  }

  // Persist new state with optimistic lock
  const newVersion = result.newVersion!  // Safe: exists after rejection check

  const updateResult = await c.env.DB.prepare(`
    UPDATE groups
    SET state = ?, version = ?, applied_log = ?, audit_log = ?, updated_at = datetime('now')
    WHERE id = ? AND version = ?
  `).bind(
    JSON.stringify(result.state),
    newVersion,
    JSON.stringify(result.appliedLog),
    JSON.stringify(result.auditLog),
    groupId,
    group.version
  ).run()

  if (updateResult.meta.changes === 0) {
    return c.json({
      status: 'conflict',
      message: 'Concurrent modification, please retry'
    }, 409)
  }

  // Broadcast update via Durable Object
  try {
    await broadcastUpdate(c.env.REALTIME, groupId, newVersion, result.state)
  } catch (e) {
    console.error('Broadcast failed:', e)
    // Don't fail the request if broadcast fails
  }

  return c.json({
    status: 'accepted',
    version: newVersion,
    state: result.state,
    noChange: result.noChange
  })
})
