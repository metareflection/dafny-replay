# MultiAction Reconciliation: When Actions are Rejected vs Reconciled

This document thoroughly describes the reconciliation behavior for `MultiAction` types in the `MultiProjectEffectStateMachine`, specifically for the collab-todo app. It covers when actions succeed, when they're reconciled through fallback candidates, and when they're definitively rejected.

---

## Overview

The MultiProject system handles two categories of actions:

1. **Single-project actions** (`Single(projectId, action)`) - wrapped ordinary actions affecting one project
2. **Cross-project actions** (`MoveTaskTo`, `CopyTaskTo`, `MoveListTo`) - operations spanning two projects

Each category has different reconciliation strategies when conflicts occur.

---

## The Reconciliation Pipeline

When a `MultiAction` is dispatched, it goes through this pipeline:

```
1. Client optimistic apply
       ↓
2. Client sends to server with baseVersions
       ↓
3. Server rebases through concurrent changes (MultiRebase)
       ↓
4. Server tries candidates in order (MultiCandidates + TryCandidates)
       ↓
5. Result: Accepted, Conflict, or Rejected
```

### Server Response Types

| Response | Meaning | Client Behavior |
|----------|---------|-----------------|
| `DispatchAccepted` | Action (or fallback) succeeded | Remove from pending, merge new state |
| `DispatchConflict` | Version mismatch, retry with fresh state | Preserve pending, retry with new versions |
| `DispatchRejected` | No candidate succeeded | Drop action, merge fresh state |

---

## Single-Project Actions: `Single(projectId, action)`

Single-project actions delegate entirely to the underlying domain's reconciliation system.

### Reconciliation Strategy

```dafny
case Single(pid, action) =>
  if pid !in mm.projects then [a]
  else
    var candidates := MC.D.Candidates(mm.projects[pid], action);
    seq(|candidates|, i => Single(pid, candidates[i]))
```

The candidates are generated by the single-project `Candidates` function, which varies by action type.

### Examples from TodoDomain

#### MoveTask (placement-aware reconciliation)

```dafny
case MoveTask(id, toList, taskPlace) =>
  var lane := TaskList(m, toList);
  if taskPlace == AtEnd then
    [MoveTask(id, toList, AtEnd)]        // Already AtEnd: no fallback needed
  else if |lane| == 0 then
    [MoveTask(id, toList, taskPlace),    // Original placement
     MoveTask(id, toList, AtEnd)]        // Fallback: place at end
  else
    var first := lane[0];
    [MoveTask(id, toList, taskPlace),    // Original placement
     MoveTask(id, toList, AtEnd),        // Fallback 1: at end
     MoveTask(id, toList, Before(first))]// Fallback 2: at beginning
```

**Reconciliation semantics:**
- If the anchor task was deleted concurrently → fallback to `AtEnd`
- If list is empty → `AtEnd` works
- The *intent* (move to this list) is preserved; only *placement* degrades

#### MoveList (list placement reconciliation)

```dafny
case MoveList(id, listPlace) =>
  if listPlace == ListAtEnd then
    [MoveList(id, ListAtEnd)]
  else
    [MoveList(id, listPlace),
     MoveList(id, ListAtEnd)]
```

#### All Other Actions (no fallback)

For actions like `AddTask`, `EditTask`, `DeleteTask`, `CompleteTask`, etc.:

```dafny
case _ => [a]  // Only the original action
```

**These actions are accepted or rejected with no degradation.**

### When Single Actions are Rejected

A single-project action is **rejected** when:

1. **Task doesn't exist**: `DeleteTask(id)` where `id` not in model
2. **List doesn't exist**: `AddTask(listId, ...)` where `listId` missing
3. **Already in target state**: `CompleteTask(id)` on already-completed task (idempotent, but returns error)
4. **Duplicate name**: `AddList(name)` where name already exists
5. **Referential integrity**: Operating on soft-deleted entities

### When Single Actions are Reconciled

A single-project action is **reconciled** (not rejected) when:

1. **Placement anchor deleted**: `MoveTask` with `Before(x)` where `x` deleted → falls back to `AtEnd`
2. **List placement changed**: `MoveList` with `ListBefore(x)` → falls back to `ListAtEnd`
3. **Concurrent modification to non-critical data**: Rebasing adjusts anchors

---

## Cross-Project Actions

Cross-project actions have their own reconciliation logic defined in `TodoMultiProjectDomain.dfy`.

### MoveTaskTo

```dafny
datatype MultiAction =
  | MoveTaskTo(
      srcProject: ProjectId,
      dstProject: ProjectId,
      taskId: TaskId,
      dstList: ListId,
      anchor: Place
    )
```

#### MultiRebase for MoveTaskTo

```dafny
case MoveTaskTo(src, dst, taskId, dstList, anchor) =>
  var srcSuffix := GetSuffix(projectLogs, baseVersions, src);
  if TaskDeletedInLog(srcSuffix, taskId) then
    Single(src, MC.D.Action.NoOp)  // Task was deleted → become NoOp
  else
    var dstSuffix := GetSuffix(projectLogs, baseVersions, dst);
    var newAnchor := RebaseAnchor(dstSuffix, anchor);
    MoveTaskTo(src, dst, taskId, dstList, newAnchor)
```

**Rebasing behavior:**
- If task was deleted in source project → transforms to `NoOp`
- If anchor task was moved in destination → degrades anchor via `DegradeIfAnchorMoved`

#### MultiCandidates for MoveTaskTo

```dafny
case MoveTaskTo(src, dst, taskId, dstList, anchor) =>
  if dst !in mm.projects then [a]
  else
    var dstModel := mm.projects[dst];
    if !SeqContains(dstModel.lists, dstList) then
      if |dstModel.lists| > 0 then
        [a, MoveTaskTo(src, dst, taskId, dstModel.lists[0], AtEnd)]
      else
        [a]  // No fallback list available
    else if anchor == AtEnd then
      [a]
    else
      [a, MoveTaskTo(src, dst, taskId, dstList, AtEnd)]
```

**Reconciliation:**
1. Original action tried first
2. If destination list missing → try first available list with `AtEnd`
3. If anchor invalid → fallback to `AtEnd` in same list

#### When MoveTaskTo is Rejected

| Condition | Result |
|-----------|--------|
| Task not in source (or deleted) | `CrossProjectError("Task not in source")` |
| Destination list doesn't exist AND no other lists | Rejected (no fallback) |
| Task already deleted after rebase | Becomes `NoOp` (accepted) |

#### When MoveTaskTo is Reconciled

| Condition | Reconciliation |
|-----------|----------------|
| Destination list deleted | → First available list in destination project |
| Anchor task deleted/moved | → `AtEnd` placement |
| Concurrent task edit in source | → Still moves (task data at move time) |

---

### CopyTaskTo

```dafny
datatype MultiAction =
  | CopyTaskTo(
      srcProject: ProjectId,
      dstProject: ProjectId,
      taskId: TaskId,
      dstList: ListId
    )
```

#### MultiRebase for CopyTaskTo

```dafny
case CopyTaskTo(src, dst, taskId, dstList) =>
  var srcSuffix := GetSuffix(projectLogs, baseVersions, src);
  if TaskDeletedInLog(srcSuffix, taskId) then
    Single(src, MC.D.Action.NoOp)
  else
    a  // Keep as-is (always copies to end of list)
```

**Rebasing behavior:**
- If source task deleted → becomes `NoOp`
- Otherwise unchanged (no anchor to rebase)

#### MultiCandidates for CopyTaskTo

```dafny
case CopyTaskTo(src, dst, taskId, dstList) =>
  if dst !in mm.projects then [a]
  else
    var dstModel := mm.projects[dst];
    if !SeqContains(dstModel.lists, dstList) then
      if |dstModel.lists| > 0 then
        [a, CopyTaskTo(src, dst, taskId, dstModel.lists[0])]
      else
        [a]
    else
      [a]
```

**Reconciliation:** Only one fallback - if destination list missing, try first available list.

#### When CopyTaskTo is Rejected

| Condition | Result |
|-----------|--------|
| Task not in source (or deleted) | `CrossProjectError("Task not in source")` |
| Destination list missing AND no other lists | Rejected |
| Source task deleted after rebase | Becomes `NoOp` (accepted) |

#### When CopyTaskTo is Reconciled

| Condition | Reconciliation |
|-----------|----------------|
| Destination list deleted | → First available list in destination |

---

### MoveListTo

```dafny
datatype MultiAction =
  | MoveListTo(
      srcProject: ProjectId,
      dstProject: ProjectId,
      listId: ListId
    )
```

#### MultiRebase for MoveListTo

```dafny
case MoveListTo(src, dst, listId) =>
  var srcSuffix := GetSuffix(projectLogs, baseVersions, src);
  if ListDeletedInLog(srcSuffix, listId) then
    Single(src, MC.D.Action.NoOp)
  else
    a  // Keep as-is
```

**Rebasing behavior:**
- If list was deleted in source → becomes `NoOp`
- Otherwise unchanged

#### MultiCandidates for MoveListTo

```dafny
case MoveListTo(src, dst, listId) =>
  [a]  // No fallback candidates
```

**No reconciliation possible** - list name conflicts are hard errors.

#### When MoveListTo is Rejected

| Condition | Result |
|-----------|--------|
| Source list missing | `CrossProjectError("Source list missing")` |
| Source list name missing | `CrossProjectError("Source list name missing")` |
| Destination has list with same name | `CrossProjectError("Duplicate list name in destination")` |
| List deleted after rebase | Becomes `NoOp` (accepted) |

#### When MoveListTo is Reconciled

**MoveListTo has no fallback reconciliation.** It either succeeds as-is or is rejected.

This is intentional:
- List names must be unique in a project
- Renaming the list would change semantics unexpectedly
- The user should resolve naming conflicts explicitly

---

## Effect State Machine Behavior

The `MultiProjectEffectStateMachine` handles server responses:

### DispatchAccepted

```dafny
case DispatchAccepted(newVersions, newModels) =>
  if es.mode.Dispatching? then
    var newClient := ClientAcceptReply(es.client, newVersions, newModels);
    // ... continue with next pending if any
```

**Behavior:**
1. First pending action removed
2. Remaining pending re-applied on merged state
3. Versions updated for touched projects

### DispatchConflict

```dafny
case DispatchConflict(freshVersions, freshModels) =>
  if es.mode.Dispatching? then
    var retries := es.mode.retries;
    if retries >= MaxRetries then
      (es.(mode := Idle), NoOp)  // Give up after 5 retries
    else
      var newClient := HandleConflict(es.client, freshVersions, freshModels);
      // ... retry with fresh state
```

**Behavior:**
1. **Pending fully preserved** (no action dropped)
2. State merged with fresh server state
3. Pending re-applied optimistically
4. Retry with incremented counter
5. After `MaxRetries` (5) → go idle (action stays in pending)

**Lemma:** `ConflictPreservesPendingExactly` proves pending is never lost on conflict.

### DispatchRejected

```dafny
case DispatchRejected(freshVersions, freshModels) =>
  if es.mode.Dispatching? then
    var newClient := ClientRejectReply(es.client, freshVersions, freshModels);
    // ... continue with next pending if any
```

**Behavior:**
1. First pending action **dropped**
2. Remaining pending re-applied on fresh state
3. Continue dispatching next action if any

---

## Summary Tables

### Single-Project Action Reconciliation

| Action | Has Fallbacks? | Fallback Strategy |
|--------|---------------|-------------------|
| AddTask | No | Accept or reject |
| EditTask | No | Accept or reject |
| DeleteTask | No | Accept or reject |
| CompleteTask | No | Accept or reject |
| StarTask | No | Accept or reject |
| SetDueDate | No | Accept or reject |
| MoveTask | Yes | Degrade placement to `AtEnd` |
| AddList | No | Accept or reject |
| RenameList | No | Accept or reject |
| DeleteList | No | Accept or reject |
| MoveList | Yes | Degrade placement to `ListAtEnd` |
| AssignTask | No | Accept or reject |
| TagTask | No | Accept or reject |

### Cross-Project Action Reconciliation

| Action | Rebasing | Fallback Strategy | Hard Rejection Cases |
|--------|----------|-------------------|----------------------|
| MoveTaskTo | Task deleted → NoOp; anchor degraded | Dest list → first list; anchor → AtEnd | Task missing, no lists in dest |
| CopyTaskTo | Task deleted → NoOp | Dest list → first list | Task missing, no lists in dest |
| MoveListTo | List deleted → NoOp | **None** | List missing, name conflict |

### Client Response Handling

| Server Response | Pending Behavior | State Behavior |
|----------------|------------------|----------------|
| DispatchAccepted | `pending[1..]` | Merge new versions/models |
| DispatchConflict | `pending` (unchanged) | Merge fresh, re-apply pending |
| DispatchRejected | `pending[1..]` | Merge fresh, re-apply rest |

---

## Verified Properties

The following properties are **proved in Dafny**:

1. **PendingNeverLost**: Actions are never silently dropped
2. **ConflictPreservesPendingExactly**: Conflicts don't remove any pending action
3. **PendingSequencePreserved**: Accept/reject removes exactly `pending[0]`
4. **UserActionAppendsExact**: User actions always append to pending
5. **RetriesBounded**: At most `MaxRetries` (5) conflict retries
6. **CandidatesStartWithOriginal**: Original action is always first candidate

---

## Design Rationale

### Why MoveListTo has no fallbacks

1. **Name semantics matter**: Renaming to avoid conflict changes meaning
2. **User intent unclear**: Should "Work" become "Work (2)"? User should decide
3. **Data integrity**: Lists carry tasks; silent renaming could cause confusion

### Why MoveTaskTo/CopyTaskTo have list fallbacks

1. **Task identity preserved**: The task itself doesn't change
2. **List is a container**: Putting it in a different container is reasonable
3. **Common scenario**: Lists get reorganized; tasks should still transfer

### Why placement fallbacks exist

1. **Intent preservation**: "Move to this list" is the primary intent
2. **Anchor is secondary**: Exact position is nice-to-have
3. **AtEnd is always valid**: A safe fallback that preserves intent

---

## Practical Implications for collab-todo

### User Experience

1. **Moving tasks between projects**: Highly resilient - will find a destination
2. **Copying tasks**: Same resilience as moving
3. **Moving lists**: Must resolve conflicts manually (name collision toast)

### Offline Behavior

Actions queued offline will be reconciled on reconnect:
- Most will succeed via fallbacks
- List moves with name conflicts will be rejected → user notified

### Concurrent Editing

- Task moves/copies: Robust to concurrent list deletion (finds new home)
- List moves: Rejected if destination adds same-named list concurrently

---

## Related Documentation

- [MULTIPROJECT.md](MULTIPROJECT.md) - Architecture overview
- [GUARANTEES.md](GUARANTEES.md) - Formal guarantee statements
- [MultiProjectEffectStateMachine.dfy](MultiProjectEffectStateMachine.dfy) - Verified state machine
- [TodoMultiProjectDomain.dfy](TodoMultiProjectDomain.dfy) - Domain-specific reconciliation
